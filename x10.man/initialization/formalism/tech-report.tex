\documentclass[a4paper]{article}

%% For typesetting theorems and some math symbols.
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{fullpage}

\title{Initialization in X10 - Technical Report}

\author{Yoav Zibin \texttt{yoav.zibin@gmail.com}}

\date{}




\input{commands}

\mynewcommand{\hvar}{\code{var}}
\mynewcommand{\hval}{\code{val}}

\mynewcommand{\async}{\code{async}}
\mynewcommand{\finish}{\code{finish}}
\newcommand{\R}[2]{\code{R}(#1,#2,\hC)}

%\newcommand{\Ofn}[1]{\ensuremath{O(#1)}}
\newcommand{\SW}[1]{\code{SW}(#1,\hC)}
\newcommand{\AW}[1]{\code{AW}(#1,\hC)}
\mynewcommand{\Read}{\code{Read}}
\mynewcommand{\SyncWrite}{\code{SyncWrite}}
\mynewcommand{\AsyncWrite}{\code{AsyncWrite}}

\mynewcommand{\hasync}{\code{async}}
\mynewcommand{\hfinish}{\code{finish}}
\mynewcommand{\hR}{\code{R}}
\mynewcommand{\hSW}{\code{SW}}
\mynewcommand{\hAW}{\code{AW}}
\mynewcommand{\hObject}{\code{Object}}

\mynewcommand{\hFM}{\code{FM}}
\mynewcommand{\hMM}{\code{MM}}
\mynewcommand{\hP}{\code{P}}

\mynewcommand{\hescaping}{\code{escaping}}
\mynewcommand{\hextends}{\code{extends}}



\begin{document}


\maketitle


\lstset{language=java,basicstyle=\ttfamily\small}

\section{Introduction}
This technical report formalizes the hardhat initialization rules in X10
    using \emph{Featherweight X10} (FX10).
Read first the paper ``Object Initialization in X10" to understand the motivation behind the hardhat rules.
    %the terminology (e.g., raw and cooked objects),
%    the initialization rules of X10,
%    and their connection with X10's concurrent and distributed constructs (\finish, \async, and \code{at}).

FX10 is similar to Featherweight Java (FJ), however it is both imperative (using a heap) and it
    models X10 specific constructs such as \finish and \async.
FX10 also models field initialization including the fact that one can read a field only after it was definitely assigned,
    and that final (\code{val}) fields can be assigned exactly once (in \Ref{Section}{val}).

FX10 does \emph{not} model other aspects of X10 such as:
\begin{description}
  \item[Places] X10 can run code in multiple places, and the \code{at} keyword is used to execute code in a different place.
    Because the only raw object is \this,
        and a raw \this cannot be captured by an \code{at},
        then only cooked objects can cross places.
    Therefore, there is no initialization issues with \code{at} and FX10 does not model it.
  \item[Inference]
    X10 uses inference in various places:
        (i)~it infers the type of a final field with an initializer,
        (ii)~it infers method return types,
        (iii)~using an inter-procedural dataflow analysis it infers
            3 sets for each non-escaping method: $\Read$, $\SyncWrite$, $\AsyncWrite$.
            $\Read$ is the set of fields that can be read by the method,
                $\SyncWrite$ are the fields that must be definitely-assigned by the method,
                and $\AsyncWrite$ are the fields that must be definitely-asynchronously-assigned by the method.

    FX10 does not model inference, and instead this information is explicitly presented.
  \item[null]
    FX10 guarantees that all fields are assigned when the object becomes cooked,
        and that fields are read only after written to.
    Therefore, \hnull is no longer needed.
    In the formalism, an object is represented as a mapping from initialized fields to their values
    (so initially the mapping is empty because no field is initialized).

  \item[Miscellaneous]
    Generics, constraints, casting, inner classes, overloading, co-variant return type, private/final,
    locals, field initializers, etc.
\end{description}


\paragraph{Overview}
\Ref{Section}{Syntax} presents the syntax of FX10.
\Ref{Section}{Typing} shows the typing rules
    (e.g., $\Gdash \he:\hC$ denotes that expression~\he has type \hC in environment $\Gamma$),
    and defines various helper functions.
\Ref{Section}{Reduction} gives the reduction rules ($\he,H \reduce \he',H'$) and our soundness proof.
Finally, \Ref{Section}{val} extends the formalism with \hval and \hvar fields.

\Section{Syntax}


\begin{figure}[htpb!]
\begin{center}
\begin{tabular}{|l|l|}
\hline

$\hP ::= \ol{\hL}$ & Program. \\

$\hL ::= \hclass ~ \hC~\hextends~\hD~\lb~\ol{\hF};~~\ctor(\ol{\hx}:\ol{\hC}) \lb~\super(\ol{\he});\he; \rb ~~\ol{\hM}~\rb$
& cLass declaration. \\

$\hF ::= \hf:\hC$
& Field declaration. \\

$\hM ::= \hMM ~ \hm(\ol{\hx}:\ol{\hC}):\hC=\he;$
& Method declaration. \\

$\hMM ::= \hescaping ~~|~~ \Read(\ol{\hf})~~\SyncWrite(\ol{\hf})~~\AsyncWrite(\ol{\hf})$
& Method Modifier. \\

$\he ::= \hl ~|~ \hx ~|~ \he.\hf ~|~ \he.\hf = \he ~|~ \he.\hm(\ol{\he}) ~|~ \hnew ~ \hC(\ol{\he})~|~ \hfinish~\he~|~ \hasync~\he;\he$
& Expressions. \\ %: locations, parameters, field access\&assignment, invocation, \code{new}

\hline
\end{tabular}
\end{center}
\caption{FX10 Syntax.
    The terminals are locations (\hl), parameters and \this (\hx), field name (\hf), method name (\hm), class name (\hB,\hC,\hD,\hObject),
        and keywords (\super, \hescaping, \Read, \SyncWrite, \AsyncWrite, \hnew, \finish, \async, \ctor).
    The program source code cannot contain locations (\hl), because locations are only created during execution/reduction in \RULE{R-New} of \Ref{Figure}{reduction}.
    }
\label{Figure:syntax}
\end{figure}


\Ref{Figure}{syntax} shows the syntax of FX10.
(\Ref{Section}{val} will later add the \hval and \hvar field modifiers.)

The syntax is similar to X10 real syntax with the following difference:
    instead of doing inference, we explicitly write the fields of \this that are initialized and read in
    every initializing method
    (using 3 sets: $\Read(\ol{\hf})$, $\SyncWrite(\ol{\hf})$, and $\AsyncWrite(\ol{\hf})$).
Initializing methods (also called non-escaping methods) cannot leak \this and they can only read fields of \this that are in the \Read set.
Non-initializing methods (whose receiver is always a cooked object) are marked with \hescaping
    because they can escape \this (e.g., pass \this as an argument to another method).

Every class has a single constructor that must initialize all the fields of \this,
    and it can only call non-escaping methods.
The constructor first calls \super to initialize the superclass's fields,
    and only then initialize the other fields.

The following is an example program in this syntax:

\begin{lstlisting}
class E extends Object {
  ctor() =
    super();
    new Object();
}
class Seq extends Object {
  ctor(a1:Object, a2:Object) =
    super();
    a2;
}
class C2 extends Object {
  fVal:E;
  fVar:E;
  ctor(a1:E, a2:E) =
    super();
    finish
      async this.fVal = a1;
      m(a2);
  Read() SyncWrite() AsyncWrite(fVar) m(a:E):E =
    async this.fVar = a;
    new E();
  escaping m2():Seq = new Seq(this,this.fVal);
}
class C3 extends Object {
  fVar:E;
  ctor(a:E) =
    super();
    new Seq(fVar=a,fVar); // ok
}
class C4 extends Object {
  fVar:E;
  ctor(a:E) =
    super();
    new Seq(fVar,fVar=a); // ERR (read before write)
}
\end{lstlisting}


\Section{Typing}
{Subtyping} is exactly as in FJ:
    the transitive closure of the \hextends relation.
That is, $\hC \st \hD$ iff $\hC=\hD$ or \hC transitively extends $\hD$.

Similarly, we define:
(i)~$\fields(\hC)=\ol{\hD}~\ol{\hf}$ returns all fields of \hC (both those declared by \hC and recursively inherited from its superclass),
    and~$\ftype{}(\hf_i,\hC) =\hD_i$.
(ii)~$\mtype(\hm,\hC) = \ol{\hB}\mapsto\hD$ returns the type of method \hm in class \hC.
(iii)~$\mbody(\hm,\hC) = \ol{\hx}.\he$ returns the method body of \hm in class \hC.
Because methods have a modifier (\hMM) in FX10, we also define:
(iv)~$\mmodifier(\hm,\hC) = \hMM$ returns the method modifier of \hm in class \hC.

Finally, because FX10 have constructors, we define:
(vi)~$\ctortype{}(\hC) = \ol{\hB}\mapsto\hC$ returns the type of the constructor in \hC,
(vii)~$\ctorbody{}(\hC) = \ol{\hx}.\hsuper(\ol{\he});\he;$ returns the body of the constructor.
(Note that constructors do not have a modifier, because they implicitly must write to all fields and cannot read any field.)


Function~$\R{\he}{F}$ returns whether
    \this does not escape from \he (i.e., \this can be used only as a field or method receiver),
    and whether
    \he only reads fields of \this that are in F or that have been previously written in e.
For example,
\beqs{R-example}
    \R{\this.\hf}{\{\hf\}}&=\htrue\\
    \R{\code{new Seq(this.f=new Object(), this.f)}}{ \emptyset}&=\htrue\\
\eeq

\beqs{R}
    &\R{[\he_0,\ldots,\he_n]}{F}= \R{\he_0}{F} \hand \R{\he_1}{\SW{[\he_0]} \cup F} \hand \ldots \hand  \R{\he_n}{\SW{[\he_0,\ldots,\he_{n-1}]} \cup F}\\
    &\R{\he"}{F}=
        \begin{cases}
        \htrue & \he" \equiv \hl \\
        \hfalse & \he" \equiv \this \\
        \htrue & \he" \equiv \hx \\
        \hf \in F & \he" \equiv \this.\hf \\
        \R{\he}{F} & \he" \equiv \he.\hf \\
        \R{\he'}{F} & \he" \equiv \this.\hf = \he' \\
        \R{[\he,\he']}{F} & \he" \equiv \he.\hf = \he' \\
        \hfalse & \he" \equiv \this.\hm(\ol{\he}) \gap \mmodifier{}(\hm,\hC)=\hescaping  \\
        R \subseteq F \hand \R{[\ol{\he}]}{F} & \he" \equiv \this.\hm(\ol{\he}) \gap \mmodifier{}(\hm,\hC)=\Read(R) \ldots  \\
        \R{[\he',\ol{\he}]}{F} & \he" \equiv \he'.\hm(\ol{\he}) \\
        \R{[\ol{\he}]}{F} & \he" \equiv \hnew ~ \hC(\ol{\he}) \\
        \R{\he}{F} & \he" \equiv \hfinish~\he \\
        \R{\he}{F} \hand \R{\he'}{F} & \he" \equiv \hasync~\he;\he' \\
        \end{cases}
\eeq


$\SW{\he}$ is the set of fields of \this that are definitely-(synchronously)-written in \he.
(The function is undefined if there is a call to an \hescaping method.)
\beqs{SW}
    &\SW{[\he_0,\ldots,\he_n]}= \SW{\he_0} \cup \ldots \cup  \SW{\he_n}\\
    &\SW{\he"}=
        \begin{cases}
        \emptyset & \he" \equiv \hl \\
        \emptyset & \he" \equiv \hx \\
        \SW{\he} & \he" \equiv \he.\hf \\
        \{ \hf \} \cup \SW{\he'} & \he" \equiv \this.\hf = \he' \\
        \SW{[\he,\he']} & \he" \equiv \he.\hf = \he' \\
        S \cup \SW{[\ol{\he}]} &
            \he" \equiv \this.\hm(\ol{\he}) \gap \mmodifier{}(\hm,\hC)=\ldots \SyncWrite(S) \ldots  \\
        \SW{[\he',\ol{\he}]} & \he" \equiv \he'.\hm(\ol{\he}) \\
        \SW{[\ol{\he}]} & \he" \equiv \hnew ~ \hC(\ol{\he}) \\
        \AW{\he} & \he" \equiv \hfinish~\he \\
        \SW{\he'} & \he" \equiv \hasync~\he;\he' \\
        \end{cases}
\eeq
$\AW{\he}$ is the set of fields of \this that are asynchronously written in \he.
Note that in $\AW{\hasync~\he;\he'}$ we collect writes to fields in both \he and $\he'$,
    whereas in $\SW{\hasync~\he;\he'}$ we only consider writes in $\he'$.
\beqs{AW}
    &\AW{[\he_0,\ldots,\he_n]}= \AW{\he_0} \cup \ldots \cup  \AW{\he_n}\\
    &\AW{\he"}=
        \begin{cases}
        \emptyset & \he" \equiv \hl \\
        \emptyset & \he" \equiv \hx \\
        \AW{\he} & \he" \equiv \he.\hf \\
        \{ \hf \} \cup \AW(\he') & \he" \equiv \this.\hf = \he' \\
        \AW{[\he,\he']} & \he" \equiv \he.\hf = \he' \\
        A \cup \AW{[\ol{\he}]} &
            \he" \equiv \this.\hm(\ol{\he}) \gap \mmodifier{}(\hm,\hC)=\ldots \AsyncWrite(A) \ldots  \\
        \AW{[\he',\ol{\he}]} & \he" \equiv \he'.\hm(\ol{\he}) \\
        \AW{[\ol{\he}]} & \he" \equiv \hnew ~ \hC(\ol{\he}) \\
        \AW{\he} & \he" \equiv \hfinish~\he \\
        \AW{\he} \cup \AW{\he'} & \he" \equiv \hasync~\he;\he' \\
        \end{cases}
\eeq




\begin{figure*}[t]
\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
    \Gdash \he : \hC
}{
  \Gdash \finish~\he~:~\hC
}$~\RULE{(T-Finish)}
\quad
$\typerule{
    \Gdash \he : \hC
        \gap
    \Gdash \he' : \hC'
}{
  \Gdash \async~\he;~\he'~:~\hC'
}$~\RULE{(T-Async)}\\\\


$\typerule{
}{
  \Gdash \hl : \Gamma(\hl)
}$~\RULE{(T-Location)}
\quad
$\typerule{
}{
  \Gdash \hx : \Gamma(\hx)
}$~\RULE{(T-Parameter)}\\\\


$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \fields{}(\hC_0)=\ol{\hf}:\ol{\hC}
}{
  \Gdash \he_0.\hf_i : \hC_i
}$~\RULE{(T-Field-Access)}\\\\

$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \fields{}(\hC_0)=\ol{\hf}:\ol{\hC}
    \gap
  \Gdash \he':\hC'
    \gap
  \hC' \st \hC_i
}{
  \Gdash \he_0.\hf_i = \he' : \hC'
}$~\RULE{(T-Field-Assign)}\\\\

$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \mtype{}(\hm,\hC_0)=\ol{\hD}\mapsto\hC
    \gap
  \Gdash \ol{\he}:\ol{\hC}
    \gap
  \ol{\hC} \st \ol{\hD}
}{
  \Gdash \he_0.\hm(\ol{\he}) : \hC
}$~\RULE{(T-Invoke)}\\\\

$\typerule{
  \ctortype{}(\hC)=\ol{\hD}\mapsto\hC
    \gap
  \Gdash \ol{\he}:\ol{\hC}
    \gap
  \ol{\hC} \st \ol{\hD}
}{
  \Gdash \hnew ~ \hC(\ol{\he}) : \hC
}$~\RULE{(T-New)}\\\\


\hline
\end{tabular}
\end{center}
\caption{FX10 Expression Typing Rules ($\Gdash \he:\hC$).
    Rules \RULE{(T-finish)} and \RULE{(T-async)} handle the new constructs in FX10,
        while the other rules are identical to those in FJ.}
\label{Figure:expression-typing}
\end{figure*}


Like in FJ, we check that method declarations are ok by ensuring that the type of the method body is a subtype
    of the return type, and that an overriding method has the same signature.
Unlike FJ, we also check that the method modifier (whether it is \hescaping or if it has the 3 sets specified).


\beqst %{method-ok}
\typerule{
  \Gamma = \{ \ol{\hx}:\ol{\hD},\this:\hC \} \\
  \Gdash \he : \hD' \gap
    \hD' \st \hD \\
  \code{if }\hMM=\Read(R)~\SyncWrite(W_s)~\AsyncWrite(W_a)\\
    ~~\code{then } \R{\he}{R} \hand W_s \subseteq W_a  \hand \SW{\he} \supseteq W_s \hand \AW{\he} \supseteq W_a
}{
  \hMM ~ \hm(\ol{\hx}:\ol{\hD}):\hD=\he ~~\OK~\IN~\hC
}~\RULE{(T-Method)}
\eeq
\beqst %{method-ok}
\typerule{
  \hclass~\hC~\hextends~\hC'~\lb~\ldots~\rb\\
  \code{if }\mtype{}(\hm,\hC')=\ol{\hD'} \mapsto \hD'\\
    ~~\code{then } \ol{\hD'}\equiv\ol{\hD} \hand \hD'\equiv\hD \\
  \code{if }\mmodifier{}(\hm,\hC')=\hMM'\\
    ~~\code{then } \hMM=\hescaping \Rightarrow \hMM'=\hescaping \hand \\
    \gap \hMM=\Read(R)~\SyncWrite(W_s)~\AsyncWrite(W_a) \Rightarrow\\
        (\hMM'=\hescaping  \hor\\
        (\hMM'=\Read(R')~\SyncWrite(W'_s)~\AsyncWrite(W'_a) \hand
            (R \subseteq R' \hand W_s \supseteq W'_s \hand W_a \supseteq W'_a))
}{
  \hMM ~ \hm(\ol{\hx}:\ol{\hD}):\hD=\he ~~\code{Override-OK}~\IN~\hC
}~\RULE{(T-Method-Override)}
\eeq

Similarly, we need to check that constructor declarations are ok by checking the \hsuper call,
    that all fields are definitely-assigned and non are read before written.
Obviously, the constructor of \hObject has no parameters.

\beqst %{ctor-ok}
\typerule{
  \Gamma = \{ \ol{\hx}:\ol{\hD},\this:\hC \} \\
  \hclass~\hC~\hextends~\hC'~\lb~\ldots~\rb\\
  F_s = \fields{}(\hC') \gap F_a = \fields{}(\hC) \gap F_d = F_a \setminus F_s \\
  \Gdash \he' : \hB' \\
  \Gdash \ol{\he} : \ol{\hB} \gap
    \ctortype{}(\hC')=\ol{\hB"} \mapsto \hC'
    \gap \ol{\hB} \st \ol{\hB"} \\
  \R{[\ol{\he}]}{\emptyset} \hand
  \R{\he'}{F_s} \hand
    \SW{\he'} \supseteq F_d
}{
  \ctor(\ol{\hx}:\ol{\hD}) \lb~\super(\ol{\he});\he'; \rb ~~\OK~\IN~\hC
}\gap \RULE{(T-Ctor)}
\eeq


As in FJ, a class is ok if its constructor \RULE{(T-Ctor)} and all its methods \RULE{(T-Method)} are ok.


\Section{Reduction}

\begin{figure*}[t]
\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
}{
  \finish~\hl,H \reduce \hl,H
}$~\RULE{(R-Finish)}
\quad
$\typerule{
}{
  \async~\hl;\he,H \reduce \he,H
}$~\RULE{(R-Async)}
\\\\

$\typerule{
    H(\hl)=\hC(\ol{\hf}\mapsto\ol{\hl'})
}{
  \hl.\hf_i,H \reduce \hl_i',H
}$~\RULE{(R-Field-Access)}
\quad
$\typerule{
    H(\hl)=\hC(F)
        \gap
    F' = F[ \hf \mapsto \hl"]
}{
  \hl.\hf=\hl",H \reduce \hl",H[ \hl \mapsto \hC(F')]
}$~\RULE{(R-Field-Assign)}
\\\\

$\typerule{
    \hl" \not \in \dom(H)
}{
  \hnew ~ \hObject(),H \reduce \hl",H[ \hl" \mapsto \hObject()]
}$~\RULE{(R-New-Object)}
\\\\

$\typerule{
    \ctorbody{}(\hC) = \ol{\hx}.\hsuper(\ol{\he});\he";
        \gap
    \hclass~\hC~\hextends~\hD
        \gap
    \hnew ~ \hD([\ol{\hl}/\ol{x}]\ol{\he}),H \reduce \hl',H'
        \gap
    H'[\hl']=\hD(F)
}{
  \hnew ~ \hC(\ol{\hl}),H \reduce [\ol{\hl}/\ol{x},\hl'/\this]\he",H'[ \hl' \mapsto \hC(F)]
}$~\RULE{(R-New)}
\\\\
$\typerule{
    H(\hl')=\hC(\ldots)
        \gap
    \mbody{}(\hm,\hC)=\ol{x}.\he
}{
  \hl'.\hm(\ol{\hl}),H \reduce [\ol{\hl}/\ol{x},\hl'/\this]\he,H
}$~\RULE{(R-Invoke)}
\\\\

$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hm(\ol{\he}),H \reduce \he'.\hm(\ol{\he}),H'
}$~\RULE{(RC-Receiver)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \hl.\hm(\ol{\hl},\he,\ol{\he}),H \reduce \hl.\hm(\ol{\hl},\he',\ol{\he}),H'
}$~\RULE{(RC-Arguments)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \hnew ~ \hC(\ol{\hl},\he,\ol{\he}),H \reduce \hnew ~ \hC(\ol{\hl},\he',\ol{\he}),H'
}$~\RULE{(RC-Ctor)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hf,H \reduce \he'.\hf,H'
}$~\RULE{(RC-Field-Access)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hf=\he",H \reduce \he'.\hf=\he",H'
}$~\RULE{(RC-Field-Assign1)}
\qquad
$\typerule{
    \he,H \reduce \he',H'
}{
  \hl.\hf=\he,H \reduce \hl.\hf=\he',H'
}$~\RULE{(RC-Field-Assign2)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \async~\he;\he",H \reduce \async~\he';\he",H'
}$~\RULE{(RC-Async1)}
\qquad
$\typerule{
    \he,H \reduce \he',H'
}{
  \async~\he";\he,H \reduce \async~\he";\he',H'
}$~\RULE{(RC-Async2)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \finish~\he,H \reduce \finish~\he',H'
}$~\RULE{(RC-Finish)}
\\

$\typerule{
}{
  (\async~\he;\hl).\hm(\ol{\he}),H \reduce \async~\he; \hl.\hm(\ol{\he}),H
}$~\RULE{(RA-Receiver)}
\\
$\typerule{
}{
  \hl.\hm(\ol{\hl},(\async~\he;\hl'),\ol{\he}),H \reduce \async~\he; \hl.\hm(\ol{\hl},\hl',\ol{\he}),H
}$~\RULE{(RA-Arguments)}
\\
$\typerule{
}{
  \hnew ~ \hC(\ol{\hl},(\async~\he;\hl'),\ol{\he}),H \reduce \async~\he; \hnew ~ \hC(\ol{\hl},\hl',\ol{\he}),H
}$~\RULE{(RA-Ctor)}
\\
$\typerule{
}{
  (\async~\he;\hl).\hf,H \reduce \async~\he; \hl.\hf,H
}$~\RULE{(RA-Field-Access)}
\\
$\typerule{
}{
  (\async~\he;\hl).\hf=\he",H \reduce \async~\he; \hl.\hf=\he",H
}$~\RULE{(RA-Field-Assign1)}
\\
$\typerule{
}{
  \hl.\hf=(\async~\he;\hl'),H \reduce \async~\he; \hl.\hf=\hl',H
}$~\RULE{(RA-Field-Assign2)}
\\\\
%
% I don't need these two rules, because RC-Async1&2 handle these cases (we can progress on either e1 or e2 in async e1;e2
%$\typerule{
%}{
%  \async~(\async~\he;\hl);\he',H \reduce \async~\he; \he',H
%}$~\RULE{(RA-Async1)}
%\qquad
%$\typerule{
%}{
%  \async~\he';(\async~\he;\hl),H \reduce \async~\he; \async~\he';\he',H
%}$~\RULE{(RA-Async2)}
%\\\\
\hline
\end{tabular}
\end{center}
\caption{FX10 Reduction Rules ($H,\he \reducesto H',\he'$).
    Rules \RULE{(RC-*)} handle the congruence rules, and
    rules \RULE{(RA-*)} handle the concurrent nature of \hasync (bringing the async to the top-level).
    Note that we do not have an \RULE{(RA-Finish)} because an async cannot cross a finish.}
\label{Figure:reduction}
\end{figure*}

An object~$\ho = \code{C}(\ol{\hf}\mapsto\ol{\hl'})$ is an instance of some class~\hC
    where fields~$\ol{\hf}$ has been initialized to locations~$\ol{\hl'}$.
A heap~$H$ is a mapping from locations~\hl to objects~$\ho$.
A heap-typing~$\Gamma_H$ maps locations to their type,
    i.e., if~$H[\hl] = \code{C}(\ldots)$ then~$\Gamma_H[\hl] = \code{C}$.
A heap~$H$ is \emph{well-typed} iff
    each field location is a subtype (using~$\Gamma_H$) of the declared field type,
    i.e., for every location in the heap~$\hl \in \dom(H)$,
        where $H[\hl] = \code{C}(\ol{\hf}\mapsto\ol{\hl'})$
        and
        for every field~$\hf_i$, we have that
        $\Gamma_H(\hl_i') \st \ftype{}(\hf_i,\hC)$.


An expression~\he is called \emph{closed} if it does not contain
    any free variables (i.e., it does not contain method parameters \hx nor~\this).


Consider a program \hP and a closed expression \he.
If a program is well-typed, then the expression can always be reduced to a location
    (therefore, a field is always read after written to).


\begin{Theorem}[preservation]
  \textbf{(Progress and Preservation)}
    For every closed expression~$\he \neq \hl$, and a well-typed heap~$H$,
        if $\Gamma_{H} \vdash \he : \hC$,
        then there exists~$H',\he',\hC'$ such that
        (i)~$H,\he \reducesto H',\he'$,
        (ii)~$\Gamma_{H'} \vdash \he':\hC'$,
        and~$\hC' \st \hC$,
        (iii)~$H'$ is well-typed,
        (iv)~$\he'$ is closed.
\end{Theorem}
\begin{proof}
\ldots
\end{proof}



\input{val}

\end{document}
