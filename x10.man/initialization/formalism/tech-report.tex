\documentclass[a4paper]{article}

%% For typesetting theorems and some math symbols.
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{fullpage}

\title{Initialization in X10 - Technical Report}

\author{Yoav Zibin \texttt{yoav.zibin@gmail.com}}

\date{}




\input{commands}

%\mynewcommand{\hvar}{\code{var}}
%\mynewcommand{\hval}{\code{val}}

\mynewcommand{\async}{\code{async}}
\mynewcommand{\finish}{\code{finish}}
%\newcommand{\Ofn}[1]{\ensuremath{O(#1)}}
\mynewcommand{\Read}{\code{Read}}
\mynewcommand{\SyncWrite}{\code{SyncWrite}}
\mynewcommand{\AsyncWrite}{\code{AsyncWrite}}

\mynewcommand{\hasync}{\code{async}}
\mynewcommand{\hfinish}{\code{finish}}
\mynewcommand{\hR}{\code{R}}
\mynewcommand{\hreceiver}{\code{receiver}} % receiver for new
\mynewcommand{\hSW}{\code{SW}}
\mynewcommand{\hAW}{\code{AW}}
\mynewcommand{\hObject}{\code{Object}}

\mynewcommand{\hFM}{\code{FM}}
\mynewcommand{\hMM}{\code{MM}}
\mynewcommand{\hP}{\code{P}}

\mynewcommand{\hescaping}{\code{escaping}}
\mynewcommand{\hextends}{\code{extends}}



\begin{document}


\maketitle


\lstset{language=java,basicstyle=\ttfamily\small}

\section{Introduction}
This technical report formalizes the hardhat initialization rules in X10
    using \emph{Featherweight X10} (FX10).
Read first the paper ``Object Initialization in X10" to understand the motivation behind the hardhat rules.
    %the terminology (e.g., raw and cooked objects),
%    the initialization rules of X10,
%    and their connection with X10's concurrent and distributed constructs (\finish, \async, and \code{at}).

FX10 is similar to Featherweight Java (FJ), however it is both imperative (using a heap) and it
    models X10 specific constructs such as \finish and \async.
FX10 also models field initialization including the fact that one can read a field only after it was definitely assigned.
%    and that final (\code{val}) fields can be assigned exactly once (in \Ref{Section}{val}).

FX10 does \emph{not} model other aspects of X10 such as:
\begin{description}
  \item[Places] X10 can run code in multiple places, and the \code{at} keyword is used to execute code in a different place.
    Because the only raw object is \this,
        and a raw \this cannot be captured by an \code{at},
        then only cooked objects can cross places.
    Therefore, there is no initialization issues with \code{at} and FX10 does not model it.
  \item[Inference]
    X10 uses inference in various places:
        (i)~it infers the type of a final field with an initializer,
        (ii)~it infers method return types,
        (iii)~using an inter-procedural dataflow analysis it infers
            3 sets for each non-escaping method: $\Read$, $\SyncWrite$, $\AsyncWrite$.
            $\Read$ is the set of fields that can be read by the method,
                $\SyncWrite$ are the fields that must be definitely-assigned by the method,
                and $\AsyncWrite$ are the fields that must be definitely-asynchronously-assigned by the method.

    FX10 does not model inference, and instead this information is explicitly presented.
  \item[null]
    Previous work on imperative variants of FJ used \hnull to initialize the object's fields.
    FX10 guarantees that all fields are assigned when the object becomes cooked,
        and that fields are read only after written to.
    Therefore, \hnull is no longer required in FX10.
    In the formalism, an object is represented as a mapping from initialized fields to their values
    (so initially the mapping is empty because no field is initialized).

  \item[Miscellaneous]
    Generics, constraints, casting, inner classes, overloading, co-variant return type, private/final,
    locals, field initializers, etc.
\end{description}


\paragraph{Overview}
\Ref{Section}{Syntax} presents the syntax of FX10.
\Ref{Section}{Typing} defines various helper functions and shows the typing rules
    (e.g., $\Gdash \he:\hC, \Delta$ denotes that expression~\he has type \hC in environment $\Gamma$, and $\Delta$ is the change to the environment after executing \he).
\Ref{Section}{Reduction} gives the reduction rules ($\he,H \reduce \he',H'$) and our soundness proof.
%Finally, \Ref{Section}{val} extends the formalism with \hval and \hvar fields.


\Section{Syntax}


\begin{figure}[htpb!]
\begin{center}
\begin{tabular}{|l|l|}
\hline

$\hP ::= \ol{\hL}$ & Program. \\

$\hL ::= \hclass ~ \hC~\hextends~\hD~\lb~\ol{\hF};~\ol{\hM}~\rb$
& cLass declaration. \\

$\hF ::= \hf:\hC$
& Field declaration. \\

$\hM ::= \hMM ~ \hm(\ol{\hx}:\ol{\hC}):\hC=\he;$
& Method declaration. \\

$\hMM ::= \hescaping ~~|~~ \Read(\ol{\hf})~~\SyncWrite(\ol{\hf})~~\AsyncWrite(\ol{\hf})$
& Method Modifier. \\

$\he ::= \hl ~|~ \hx ~|~ \he.\hf ~|~ \he.\hf = \he ~|~ \he.\hm(\ol{\he}) ~|~ \hnew{\hC}~|~ \hfinish~\he~|~ \hasync~\he;\he~|~ \he;\he$
& Expressions. \\ %: locations, parameters, field access\&assignment, invocation, \code{new}

\hline
\end{tabular}
\end{center}
\caption{FX10 Syntax.
    The terminals are locations (\hl), parameters and \this (\hx), field name (\hf), method name (\hm), class name (\hB,\hC,\hD,\hObject),
        and keywords/symbols (\super, \hescaping, \Read, \SyncWrite, \AsyncWrite, \hhnew, \finish, \async, $;$, $.$, $(\ldots)$).
    The program source code cannot contain locations (\hl), because locations are only created during execution/reduction in \RULE{R-New} of \Ref{Figure}{reduction}.
    }
\label{Figure:syntax}
\end{figure}


\Ref{Figure}{syntax} shows the syntax of FX10.
%(\Ref{Section}{val} will later add the \hval and \hvar field modifiers.)
Expression~$\hasync~\he;\he'$ means evaluate \he concurrently (in a different thread) while the result is the evaluation of $\he'$.

The syntax is similar to X10 real syntax with the following difference:
    instead of doing inference, we explicitly write the fields of \this that are initialized and read in
    every initializing method
    (using 3 sets: $\Read(\ol{\hf})$, $\SyncWrite(\ol{\hf})$, and $\AsyncWrite(\ol{\hf})$).
Initializing methods (also called non-escaping methods) cannot leak \this and they can only read fields of \this that are in the \Read set.
Non-initializing methods (whose receiver is always a cooked object) are marked with \hescaping
    because they can escape \this (e.g., pass \this as an argument to another method).



\Section{Typing}
{Subtyping} is exactly as in FJ:
    the transitive closure of the \hextends relation.
That is, $\hC \st \hD$ iff $\hC=\hD$ or \hC transitively extends $\hD$.

Similarly, we define:
(i)~$\fields(\hC)=\ol{\hD}~\ol{\hf}$ returns all fields of \hC (both those declared by \hC and recursively inherited from its superclass),
    and~$\ftype{}(\hf_i,\hC) =\hD_i$.
(ii)~$\mtype(\hm,\hC) = \ol{\hB}\mapsto\hD$ returns the type of method \hm in class \hC.
(iii)~$\mbody(\hm,\hC) = \ol{\hx}.\he$ returns the method body of \hm in class \hC.
Because methods have a modifier (\hMM) in FX10, we also define:
(iv)~$\mmodifier(\hm,\hC) = \hMM$ returns the method modifier of \hm in class \hC.



\begin{figure*}[t]
\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
    \Gdash \he : \hC
}{
  \Gdash \finish~\he~:~\hC
}$~\RULE{(T-Finish)}
\quad
$\typerule{
    \Gdash \he : \hC
        \gap
    \Gdash \he' : \hC'
}{
  \Gdash \async{}~\he;~\he'~:~\hC'
}$~\RULE{(T-Async)}
\quad
$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \Gdash \he':\hC'
}{
  \Gdash \he_0;\he' : \hC'
}$~\RULE{(T-Seq)}\\\\

$\typerule{
}{
  \Gdash \hl : \Gamma(\hl)
}$~\RULE{(T-Location)}
\quad
$\typerule{
}{
  \Gdash \hx : \Gamma(\hx)
}$~\RULE{(T-Parameter)}\\\\


$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \fields{}(\hC_0)=\ol{\hf}:\ol{\hC}
}{
  \Gdash \he_0.\hf_i : \hC_i
}$~\RULE{(T-Field-Access)}\\\\

$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \fields{}(\hC_0)=\ol{\hf}:\ol{\hC}
    \gap
  \Gdash \he':\hC'
    \gap
  \hC' \st \hC_i
}{
  \Gdash \he_0.\hf_i = \he' : \hC'
}$~\RULE{(T-Field-Assign)}\\\\


$\typerule{
  \Gdash \he_0:\hC_0
    \gap
  \mtype{}(\hm,\hC_0)=\ol{\hD}\mapsto\hC
    \gap
  \Gdash \ol{\he}:\ol{\hC}
    \gap
  \ol{\hC} \st \ol{\hD}
}{
  \Gdash \he_0.\hm(\ol{\he}) : \hC
}$~\RULE{(T-Invoke)}\\\\

$\typerule{
    F = \fields(\hC)
}{
  \Gdash \hnew{\hC} : \hC \myinit{F}{F}
}$~\RULE{(T-New)}\\\\


\hline
\end{tabular}
\end{center}
\caption{FX10 Expression Typing Rules ($\Gdash \he:\hC$).
    Rules \RULE{(T-finish)} and \RULE{(T-async)} handle the new constructs in FX10,
        while the other rules are identical to those in FJ.}
\label{Figure:expression-typing}
\end{figure*}


Like in FJ, we check that method declarations are ok by ensuring that the type of the method body is a subtype
    of the return type, and that an overriding method has the same signature.
Unlike FJ, we also check that the method modifier (whether it is \hescaping or if it has the 3 sets specified).


\beqst %{method-ok}
\typerule{
  t  =
        \begin{cases}
        \hC\mycooked & \hMM=\hescaping \\
        \hC\myinit{A}{A}  & \hMM=\Read(R)~\SyncWrite(W_s)~\AsyncWrite(W_a) \qquad A=* \cup \fields{}(\hC) \setminus R \\
        \end{cases}\\
  \Gamma = \{ \ol{\hx}:\ol{\hD\mycooked},\this:t \} \\
  \Gdash \he : \hD'\mycooked,\Delta \gap
    \hD' \st \hD \\
  \code{if }\hMM=\Read(R)~\SyncWrite(W_s)~\AsyncWrite(W_a)\\
  %todo
    ~~\code{then }  \Delta(\this) = \hC\myinit{f_s}{f_a} \hand W_s \subseteq W_a  \hand f_s \supseteq W_s \hand f_a \supseteq W_a
}{
  \hMM ~ \hm(\ol{\hx}:\ol{\hD}):\hD=\he ~~\OK~\IN~\hC
}~\RULE{(T-Method)}
\eeq
\beqst %{method-ok}
\typerule{
  \hclass~\hC~\hextends~\hC'~\lb~\ldots~\rb\\
  \code{if }\mtype{}(\hm,\hC')=\ol{\hD'} \mapsto \hD'\\
    ~~\code{then } \ol{\hD'}\equiv\ol{\hD} \hand \hD'\equiv\hD \\
  \code{if }\mmodifier{}(\hm,\hC')=\hMM'\\
    ~~\code{then } \hMM=\hescaping \Rightarrow \hMM'=\hescaping \hand \\
    \gap \hMM=\Read(R)~\SyncWrite(W_s)~\AsyncWrite(W_a) \Rightarrow\\
        (\hMM'=\hescaping  \hor\\
        (\hMM'=\Read(R')~\SyncWrite(W'_s)~\AsyncWrite(W'_a) \hand
            (R \subseteq R' \hand W_s \supseteq W'_s \hand W_a \supseteq W'_a))
}{
  \hMM ~ \hm(\ol{\hx}:\ol{\hD}):\hD=\he ~~\code{Override-OK}~\IN~\hC
}~\RULE{(T-Method-Override)}
\eeq


As in FJ, a class is ok if all its methods \RULE{(T-Method)} are ok.


\Section{Reduction}

\begin{figure*}[t]
\begin{center}
\begin{tabular}{|c|}
\hline
$\typerule{
}{
  \finish~\hl,H \reduce \hl,H
}$~\RULE{(R-Finish)}
\quad
$\typerule{
}{
  \async~\hl;\he,H \reduce \he,H
}$~\RULE{(R-Async)}
\\\\

$\typerule{
    H(\hl)=\hC(\ol{\hf}\mapsto\ol{\hl'})
}{
  \hl.\hf_i,H \reduce \hl_i',H
}$~\RULE{(R-Field-Access)}
\quad
$\typerule{
    H(\hl)=\hC(F)
        \gap
    F' = F[ \hf \mapsto \hl"]
}{
  \hl.\hf=\hl",H \reduce \hl",H[ \hl \mapsto \hC(F')]
}$~\RULE{(R-Field-Assign)}
\\\\

$\typerule{
}{
  \hl;\he,H \reduce \he,H
}$~\RULE{(R-Seq)}
\\\\

$\typerule{
    \hl" \not \in \dom(H)
}{
  \hnew{\hC},H \reduce \hl",H[ \hl" \mapsto \hC()]
}$~\RULE{(R-New)}
\\\\
$\typerule{
    H(\hl')=\hC(\ldots)
        \gap
    \mbody{}(\hm,\hC)=\ol{x}.\he
}{
  \hl'.\hm(\ol{\hl}),H \reduce [\ol{\hl}/\ol{x},\hl'/\this]\he,H
}$~\RULE{(R-Invoke)}
\\\\

$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hm(\ol{\he}),H \reduce \he'.\hm(\ol{\he}),H'
}$~\RULE{(RC-Receiver)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \hl.\hm(\ol{\hl},\he,\ol{\he}),H \reduce \hl.\hm(\ol{\hl},\he',\ol{\he}),H'
}$~\RULE{(RC-Arguments)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \he;\he",H \reduce \he';\he",H'
}$~\RULE{(RC-Seq)}
\quad
$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hf,H \reduce \he'.\hf,H'
}$~\RULE{(RC-Field-Access)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hf=\he",H \reduce \he'.\hf=\he",H'
}$~\RULE{(RC-Field-Assign1)}
\qquad
$\typerule{
    \he,H \reduce \he',H'
}{
  \hl.\hf=\he,H \reduce \hl.\hf=\he',H'
}$~\RULE{(RC-Field-Assign2)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \async~\he;\he",H \reduce \async~\he';\he",H'
}$~\RULE{(RC-Async1)}
\qquad
$\typerule{
    \he,H \reduce \he',H'
}{
  \async~\he";\he,H \reduce \async~\he";\he',H'
}$~\RULE{(RC-Async2)}
\\\\
$\typerule{
    \he,H \reduce \he',H'
}{
  \finish~\he,H \reduce \finish~\he',H'
}$~\RULE{(RC-Finish)}
\\

$\typerule{
}{
  (\async~\he;\hl).\hm(\ol{\he}),H \reduce \async~\he; \hl.\hm(\ol{\he}),H
}$~\RULE{(RA-Receiver)}
\\
$\typerule{
}{
  \hl.\hm(\ol{\hl},(\async~\he;\hl'),\ol{\he}),H \reduce \async~\he; \hl.\hm(\ol{\hl},\hl',\ol{\he}),H
}$~\RULE{(RA-Arguments)}
\\
$\typerule{
}{
  (\async~\he;\hl).\hf,H \reduce \async~\he; \hl.\hf,H
}$~\RULE{(RA-Field-Access)}
\\
$\typerule{
}{
  (\async~\he;\hl).\hf=\he",H \reduce \async~\he; \hl.\hf=\he",H
}$~\RULE{(RA-Field-Assign1)}
\\
$\typerule{
}{
  \hl.\hf=(\async~\he;\hl'),H \reduce \async~\he; \hl.\hf=\hl',H
}$~\RULE{(RA-Field-Assign2)}
\\\\
%
% I don't need these two rules, because RC-Async1&2 handle these cases (we can progress on either e1 or e2 in async e1;e2
%$\typerule{
%}{
%  \async~(\async~\he;\hl);\he',H \reduce \async~\he; \he',H
%}$~\RULE{(RA-Async1)}
%\qquad
%$\typerule{
%}{
%  \async~\he';(\async~\he;\hl),H \reduce \async~\he; \async~\he';\he',H
%}$~\RULE{(RA-Async2)}
%\\\\
\hline
\end{tabular}
\end{center}
\caption{FX10 Reduction Rules ($H,\he \reducesto H',\he'$).
    Rules \RULE{(RC-*)} handle the congruence rules, and
    rules \RULE{(RA-*)} handle the concurrent nature of \hasync (bringing the async to the top-level).
    Note that we do not have an \RULE{(RA-Finish)} because an async cannot cross a finish.}
\label{Figure:reduction}
\end{figure*}

An object~$\ho = \code{C}(\ol{\hf}\mapsto\ol{\hl'})$ is an instance of some class~\hC
    where fields~$\ol{\hf}$ has been initialized to locations~$\ol{\hl'}$.
A heap~$H$ is a mapping from locations~\hl to objects~$\ho$.
A heap-typing~$\Gamma_H$ maps locations to their type,
    i.e., if~$H[\hl] = \code{C}(\ldots)$ then~$\Gamma_H[\hl] = \code{C}$.
A heap~$H$ is \emph{well-typed} iff
    each field location is a subtype (using~$\Gamma_H$) of the declared field type,
    i.e., for every location in the heap~$\hl \in \dom(H)$,
        where $H[\hl] = \code{C}(\ol{\hf}\mapsto\ol{\hl'})$
        and
        for every field~$\hf_i$, we have that
        $\Gamma_H(\hl_i') \st \ftype{}(\hf_i,\hC)$.


An expression~\he is called \emph{closed} if it does not contain
    any free variables (i.e., it does not contain method parameters \hx nor~\this).


Consider a program \hP and a closed expression \he.
We always assume the program is well-typed.
Then in a well-typed heap, a closed expression can always be reduced to a location.
Because our reduction rules only allow reads from initialized fields,
    then a corollary is that a field can only be read after it was assigned.


\begin{Theorem}[preservation]
  \textbf{(Progress and Preservation)}
    For every closed expression~$\he \neq \hl$, and a well-typed heap~$H$,
        if $\Gamma_{H} \vdash \he : \hC$,
        then there exists~$H',\he',\hC'$ such that
        (i)~$H,\he \reducesto H',\he'$,
        (ii)~$\Gamma_{H'} \vdash \he':\hC'$,
        and~$\hC' \st \hC$,
        (iii)~$H'$ is well-typed,
        (iv)~$\he'$ is closed.
\end{Theorem}
\begin{proof}
We will break the proof into several lemmas, each proving points (i)--(iv).
\end{proof}

\begin{Lemma}[closed]
  \textbf{(Closed is preserved)}
    For every closed expression~$\grave{\he} \neq \hl$, and a well-typed heap~$H$,
        if $H,\grave{\he} \reducesto H',\acute{\he}$,
        then $\acute{\he}$ is closed.
\end{Lemma}
\begin{proof}
Let's consider all the possible reduction rules in \Ref{Figure}{reduction}.
We will prove by induction on the size of $\he$.

Consider \RULE{R-Async}, where~$\grave{\he} = \async~\hl;\acute{\he}$:
\[\typerule{
}{
  \async~\hl;\acute{\he},H \reduce \acute{\he},H
}
\]
Then, because $\grave{\he}$ is closed, then $\acute{\he}$ is closed.

Consider \RULE{RC-Receiver}, where~$\grave{\he} = \he.\hm(\ol{\he})$:
\[\typerule{
    \he,H \reduce \he',H'
}{
  \he.\hm(\ol{\he}),H \reduce \he'.\hm(\ol{\he}),H'
}
\]
By induction (the size of~$\he$ is smaller than the size of~$\grave{\he}$), we have that~$\he'$ is closed.
Therefore,~$\acute{\he} = \he'.\hm(\ol{\he})$ is closed.

The only remaining two interesting cases are~\RULE{R-New} and~\RULE{R-Invoke}.
Consider~\RULE{R-Invoke} (\RULE{R-New} is handled similarly), where~$\grave{\he} = \hl'.\hm(\ol{\hl})$:
\[
\typerule{
    H(\hl')=\hC(\ldots)
        \gap
    \mbody{}(\hm,\hC)=\ol{x}.\he
}{
  \hl'.\hm(\ol{\hl}),H \reduce [\ol{\hl}/\ol{x},\hl'/\this]\he,H
}
\]
Note that \he might not be closed, i.e., it may contain method parameters or \this.
However, because the program is well-typed and~$\mbody{}(\hm,\hC)=\ol{x}.\he$,
    then \he may only contain either~$\hx_i$ or \this,
    and these are substituted by locations in~$[\ol{\hl}/\ol{x},\hl'/\this]\he$,
    thus~$\grave{\he}$ is closed.
\end{proof}

\begin{Lemma}[well-typed]
  \textbf{(Heap is well-typed)}
    For every closed expression~$\grave{\he} \neq \hl$, and a well-typed heap~$H$,
        if $H,\grave{\he} \reducesto H',\acute{\he}$,
        then $H'$ is well-typed.
\end{Lemma}
\begin{proof}
Let's consider all the possible reduction rules in \Ref{Figure}{reduction}.
We will prove by induction on the size of $\he$.

For the following rules we have that~$H=H'$, thus $H'$ is well-typed:
\RULE{R-Finish}
\RULE{R-Async}
\RULE{R-Field-Access}


\RULE{R-Field-Assign}

\end{proof}

%\input{val}

\end{document}
