\chapter{Activities}\label{XtenActivities}

An {\em activity} is a statement being executed, independently, with its own
local variables; it may be thought of as a very light-weight thread. An
\Xten{} computation may have many concurrent {\em activities} executing at any
give time.  All X10 code runs as part of an activity; when an X10 program is
started, the \xcd`main` method is invoked in an activity, called the {\em root
activity}.\index{root
activity}


Activities coordinate their execution by various control and data structures.
For example, `
%~~stmt~~`~~`~~x:Int, var y:Int ~~
\xcd`when(x==0);` blocks the current activity until some other activity
sets \xcd`x` to zero.  However, activities determine the places at which they
may be blocked and resumed, by \xcd`when` and similar constructs.  There are
no means by which one activity can arbitrarily interrupt, block, or resume
another, no method  \xcd`activity.interrupt()`.

An activity may be {\em running}, {\em blocked} on some condition or {\em
terminated}. If it is terminated, it is terminated in the same way that its
statement is: in particular, if the statement terminates abruptly, the
activity terminates abruptly for the same reason.
(\Sref{ExceptionModel}).

Activities can be long-running entities with a good deal of local state.  In
particular they can involve recursive method calls (and therefore have runtime
stacks).  However, activities can also be short-running light-weight entities,
\eg, it is reasonable to have an activity that simply increments a variable.

An activity may asynchronously and in parallel launch activities at
other places.  Every activity except the initial \xcd`main` activity is spawned
by another.  Thus, at any instant, the activities in a program form a tree.

X10 uses this tree in crucial ways.  
First is the distinction 
between {\em local} termination and {\em global}
termination of a statement. The execution of a statement by an
activity is said to terminate locally when the activity has finished
all its computation. (For instance the
creation of an asynchronous activity terminates locally when the
activity has been created.)  It is said to terminate globally when it
has terminated locally and all activities that it may have spawned at
any place have, recursively, terminated globally.
For example, consider: 
%~~gen
% package Activites.Are.For.Whacktivities;
% class Example {
% def example( s1:() => Void, s2 : () => Void ) {
%~~vis
\begin{xten}
async {s1();}
async {s2();}
\end{xten}
%~~siv
% } } 
%~~neg
The primary activity spawns two child activities and then terminates locally,
very quickly.  The child activities may take arbitrary amounts of time to
terminate (and may spawn grandchildren).  When \xcd`s1()`, \xcd`s2()`, and
all their descendants terminate locally, then the primary activity terminates
globally. 

The program as a whole terminates when the root activity terminates globally.
In particular, X10 does not permit the creation of 
daemon threads---threads that outlive the lifetime of the root
activity.  We say that an \Xten{} computation is {\em rooted}
(\Sref{initial-computation}).

\futureext{ We may permit the initial activity to be a daemon activity
to permit reactive computations, such as webservers, that may not
terminate.}

\section{The \Xten{} rooted exception model}
\label{ExceptionModel}
\index{Exception!model}

The rooted nature of \Xten{} computations permits the definition of a
{\em rooted exception model.} In multi-threaded programming languages
there is a natural parent-child relationship between a thread and a
thread that it spawns. Typically the parent thread continues execution
in parallel with the child thread. Therefore the parent thread cannot
serve to catch any exceptions thrown by the child thread. 

The presence of a root activity and the concept of global termination permits
\Xten{} to adopt a more powerful exception model. In any state of the
computation, say that an activity $A$ is {\em a root of} an activity $B$ if
$A$ is an ancestor of $B$ and $A$ is blocked at a statement (such as the
\xcd"finish" statement \Sref{finish}) awaiting the termination of $B$ (and
possibly other activities). For every \Xten{} computation, the \emph{root-of}
relation is guaranteed to be a tree. The root of the tree is the root activity
of the entire computation. If $A$ is the nearest root of $B$, the path from
$A$ to $B$ is called the {\em activation path} for the activity.\footnote{Note
  that depending on the state of the computation the activation path may
  traverse activities that are running, blocked or terminated.}

We may now state the exception model for \Xten.  An uncaught exception
propagates up the activation path to its nearest root activity, where
it may be handled locally or propagated up the \emph{root-of} tree when
the activity terminates (based on the semantics of the statement being
executed by the activity).\footnote{In \XtenCurrVer{} the \xcd"finish"
statement is the only statement that marks its activity as a root
activity. Future versions of the language may introduce more such
statements.}  In Java, exceptions may be overlooked because there is no good
place to put a \xcd`try`-\xcd`catch` block; this is never the case in X10.

\section{ {\tt at}: Place Changing and Object Copying}\label{AtStatement}
\index{at}

An activity may change place using the \xcd"at" statement or
\xcd"at" expression:

\begin{grammar}
Statement \: AtStatement \\
AtStatement \: \xcd"at" PlaceExpressionSingleList Statement \\
Expression \: AtExpression \\
AtExpression \: \xcd"at" PlaceExpressionSingleList ClosureBody 
\end{grammar}

The statement \xcd"at (p) S" executes the statement \xcd"S"
synchronously at a place described by \xcd"p".
The expression \xcd"at (p) E" executes the statement \xcd"E"
synchronously at place \xcd"p", returning the result to the
originating place.  




\xcd`p` may be an expression of type \xcd`Place`, in which case its value is
used as the place to execute the body: 
%~~gen
% package Activities.At.A.Standstill;
% class Example {
% def example(ob: Object, S: ()=>Void) {
%~~vis
\begin{xten}
   at (here.next()) S();
\end{xten}
%~~siv
% } } 
%~~neg
\noindent



\xcd`at(p)S` does {\em not} start a new activity.  It should be thought of as
transporting the current activity to \xcd`p`, running \xcd`S` there, and then
transporting it back.    If you want to start a new activity, use \xcd`async`;
if you want to start a new activity at \xcd`p`, use 
\xcd`at(p) async S`.  

As a consequence of this, \xcd`S` may contain constructs which only make sense
within a single activity.  
For example, 
\begin{xten}
    for(x in globalRefsToThings) 
      if (at(x.home) x().nice()) 
        return x();
\end{xten}
returns the first nice thing in a collection.   If we had used 
\xcd`async at(x.home)`, this would not be allowed; 
you can't \xcd`return` from an
\xcd`async`. 

\subsection{Implicit copying from {\tt at} }
\index{at!copying}

\xcd`at(p)S` copies nearly all data that \xcd`S` might reference, and sends it
to place \xcd`p`, before executing \xcd`S` there. The only things that are not
copied are values only reachable through \xcd`GlobalRef`s.    If \xcd`x` is a
variable name referring to some object \xcd`ob` outside of \xcd`S`, then the
same variable name \xcd`x` refers to a deep copy \xcd`ob{$'$}` of \xcd`ob`
inside of \xcd`S`.  In this way the body \xcd`S` is in a separate block with
different variable bindings.

For example, consider the following program.
%~~gen
% package Activities.implicitcopyfromat;
% class Example {
% def example() {
%~~vis
\begin{xten}
val c = new Cell[Int](5); // (1)
at (here) {               // (2)
   assert(c() == 5);      // (3)
   c.set(8);              // (4)
   assert(c() == 8);      // (5)
}
assert(c() == 5);         // (6)
\end{xten}
%~~siv
%}}
%~~neg
The \xcd`at` statement implicitly copies the \xcd`Cell` and its contents.  
After \xcd`(1)`, \xcd`c` is a \xcd`Cell` containing 5; call that cell {$c_1$}
At \xcd`(2)`, that cell is copied, resulting in another cell {$c_2$} whose
contents are also 5, as tested at \xcd`(3)`.
(Note that the copying behavior of \xcd`at` happens {\em even when the
destination place is the same as the starting place}--- even with
\xcd`at(here)`.)
At \xcd`(4)`, the contents of {$c_2$} are changed to 8, as confirmed at \xcd`(5)`; the contents of
{$c_1$} are of course untouched.    Finally, at \xcd`(c)`, outside the scope
of the \xcd`at` started at line \xcd`(2)`, \xcd`c` refers to its original
value {$c_1$} rather than the copy {$c_2$}.  

The \xcd`at` statement induces a {\em deep copy}.  Not only does it copy the
values of variables, it copies values that they refer to through zero or more
levels of reference.  Structures are preserved as well: if two fields
\xcd`x.f` and \xcd`x.g` refer to the same object {$o_1$} in the original, then
\xcd`x.f` and \xcd`x.g` will both refer to the same object {$o_2$} in the
copy.  

For example, in the following variation of the preceding example,
\xcd`a`'s original value {$a_1$} is an array with two references to the same
\xcd`Cell[Int]` {$c_1$}.  The fact that {$a_1(0)$} and {$a_1(1)$} are both
identical to {$c_1$} is demonstrated in \xcd`(A)`-\xcd`(C)`, as {$a_1(0)$} is modified
and {$a_1(1)$} is observed to change.  In \xcd`(D)`-\xcd`(F)`, the copy
{$a_2$} is tested in the same way, showing that {$a_2(0)$} and {$a_2(1)$} both
refer to the same \xcd`Cell[Int]` {$c_2$}.  However, the test at \xcd`(G)`
shows that {$c_2$} is a different cell from {$c_1$}, because changes to
{$c_2$} did not propagate to {$c_1$}.  
%~~gen
%package Activities.AtCopy2;
%class example {
%static def Example() {
%~~vis
\begin{xten}
val c = new Cell[Int](5);
val a = new Array[Cell[Int]][c,c];
assert(a(0)() == 5 && a(1)() == 5);     // (A)
c.set(6);                               // (B)
assert(a(0)() == 6 && a(1)() == 6);     // (C)
at(here) {
  assert(a(0)() == 6 && a(1)() == 6);   // (D)
  c.set(7);                             // (E)
  assert(a(0)() == 7 && a(1)() == 7);   // (F)
}
assert(a(0)() == 6 && a(1)() == 6);     // (G)
\end{xten}
%~~siv
%}}
%~~neg


\subsubsection{Copying and GlobalRef}
\index{at!GlobalRef}
\index{at!blocking copying}

The single barrier to the potentially copious copying behavior of \xcd`at`
is the \xcd`GlobalRef` struct.  A \xcd`GlobalRef[T]` contains a reference to
a value of type \xcd`T`, in a form which can be transmitted, and a \xcd`Place`
\xcd`gr.home` indicating where the value lives.
The \xcd`GlobalRef` itself is copied across
\xcd`at` boundaries---but the value referred to is {\em not}
copied.\footnote{Strictly: the reference from the {\tt GlobalRef} does not
inspire copying.  Copying may be required due to some other, non-Global
reference.} 

The following example does not copy the value \xcd`huge`.  However, \xcd`huge`
would have been copied if it had been put into a \xcd`Cell`, or simply used
directly. 
%~~gen
%package Activities.copyingblockingwithglobref;
% class GR {
%  static def use(Any){}
%  static def example() {
%~~vis
\begin{xten}
val huge = "A potentially big thing";
val href = GlobalRef(huge);
at (here) {
   use(href);
  }
}
\end{xten}
%~~siv
%}
%~~neg


Values protected in \xcd`GlobalRef`s can be retrieved by the \xcd`gr.apply()`
method, often abbreviated simply \xcd`gr()`.  \xcd`gr.apply()` is guarded; it can
only be called when \xcd`gr.home == here`.  If you  want to do anything other
than pass a global reference around or compare two of them for equality, you
need to placeshift back to the home place of the reference, often with
\xcd`at(gr.home)`.   For example, the following (silly) program modifies the
command-line argument array.

%~~gen
% package Activities.Atsome.Globref2;
% class GR2 {
%~~vis
\begin{xten}
  public static def main(argv: Array[String](1)) {
    val argref = GlobalRef[Array[String](1)](argv);
    at(here.next()) use(argref);
  }
  static def use(argref : GlobalRef[Array[String](1)]) {
    at(argref.home) {
      val argv = argref();
      argv(0) = "Hi!";
    }
  }
\end{xten}
%~~siv
%}
%~~neg





\subsubsection{Warnings about \xcd`at`}
There are two dangers involved with \xcd`at`: 
\begin{itemize}
\item Careless use of \xcd`at` can result in copying and transmission
of very large data structures.  
\item As seen in the examples above, changes made to copied objects are not
      propagated back to the originals.   
\end{itemize}

\section{\xcd`async`: Spawning an activity}\label{AsynchronousActivity}\label{AsyncActivity}

Asynchronous activities serve as a single abstraction for supporting a
wide range of concurrency constructs such as message passing, threads,
DMA, streaming, data prefetching. (In general, asynchronous operations
are better suited for supporting scalability than synchronous
operations.)

An activity is created by executing the \xcd`async` statement: 

\begin{grammar}
Statement \: AsyncStatement \\
AsyncStatement \: \xcd"async"  Statement \\
PlaceExpressionSingleList \: \xcd"(" PlaceExpression \xcd")" \\
PlaceExpression \: Expression 
\end{grammar} 


The basic form of \xcd`async` is \xcd`async S`, which starts a new activity
located \xcd`here` executing \xcd`S`.   


\bard{The followingin para is under investigation:}
In many cases the compiler may infer the unique place at which the
statement is to be executed by an analysis of the types of the
variables occurring in the statement. (The place must be such that the
statement can be executed safely, without generating a
\xcd"BadPlaceException".) In such cases the programmer may omit the
place designator; the compiler will throw an error if it cannot
determine the unique designated place.\footnote{\XtenCurrVer{} does
not specify a particular algorithm; this will be fixed in future
versions.}

An activity $A$ executes the statement \xcd"async (P) S" by launching
a new activity $B$ at place \xcd`P` (or \xcd`P.home` if \xcd`P` is of an
object type), to execute \xcd`S`. The statement terminates locally as soon as $B$ is
launched.  The activation path for $B$ is that of $A$ augmented by the
information that {$A$} is the parent of {$B$}. 
$B$
terminates normally when $S$ terminates normally.  It terminates
abruptly if $S$ throws an uncaught exception. The exception is
propagated to $A$ if $A$ is a root activity (see \Sref{finish}),
otherwise it is propagated through $A$ to $A$'s root activity. Note that while
{$A$} is running, exceptions thrown by activities it has already
spawned may propagate through it up to its root activity, without {$A$} noticing.

Multiple activities launched by a single activity at another place are not
ordered in any way. They are added to the set of activities at the target
place and will be executed based on the local scheduler's decisions.
If some particular sequencing of events is needed, \xcd`when`, \xcd`atomic`,
\xcd`finish`, clocks, and other X10 constructs can be used.
\Xten{} implementations are not required to have fair schedulers,
though every implementation should make a best faith effort to ensure
that every activity eventually gets a chance to make forward progress.

\begin{staticrule*}
The statement in the body of an \xcd"async" is subject to the
restriction that it must be acceptable as the body of a \xcd"void"
method for an anonymous inner class declared at that point in the code,
which throws no checked exceptions. As such, it may reference
variables in lexically enclosing scopes (including \xcd"clock"
variables, \Sref{XtenClocks}) provided that such variables are
(implicitly or explicitly) \xcd"val".
\end{staticrule*}

\section{Finish}\index{finish}\label{finish}
The statement \xcd"finish S" converts global termination to local
termination and introduces a root activity.   It executes \xcd`S`, and then
waits for all activities spawned by \xcd`S`, directly or indirectly, to
finish. It also collects exceptions thrown by those activities.

\begin{grammar}
Statement \: FinishStatement \\
FinishStatement \: \xcd"finish" Statement 
\end{grammar}

An activity $A$ executes \xcd"finish S" by executing \xcd"S".  The
execution of \xcd"S" may spawn other asynchronous activities (here or
at other places).  Uncaught exceptions thrown or propagated by any
activity spawned by \xcd"S" are accumulated at \xcd"finish S".
\xcd"finish S" terminates locally when all activities spawned by
\xcd"S" terminate globally (either abruptly or normally). If \xcd"S"
terminates normally, then \xcd"finish S" terminates normally and $A$
continues execution with the next statement after \xcd"finish S".  If
\xcd"S" terminates abruptly, then \xcd"finish S" terminates abruptly
and throws a single exception, \Xcd{x10.lang.MultipleExceptions}
formed from the collection of exceptions accumulated at \xcd"finish S".

Thus a \xcd"finish S" statement serves as a collection point for
uncaught exceptions generated during the execution of \xcd"S".

Note that repeatedly \xcd"finish"ing a statement has little effect after
the first \xcd"finish": \xcd"finish finish S" is indistinguishable
from \xcd"finish S" if \xcd`S` throws no exceptions.  (If \xcd`S` throws
exceptions, \xcd`finish S` wraps them in one layer of 
\xcd`MultipleExceptions` and \xcd`finish finish S` in two layers.)

%%OLIVIER-DENIES%% \paragraph{Interaction with clocks.}\label{sec:finish:clock-rule}
%%OLIVIER-DENIES%% 
%%OLIVIER-DENIES%% \xcd"finish S" interacts with clocks (\Sref{XtenClocks}). 
%%OLIVIER-DENIES%% While executing \xcd"S", an activity must not spawn any \xcd"clocked"
%%OLIVIER-DENIES%% asyncs. (Asyncs spawned during the execution of \xcd"S" may spawn
%%OLIVIER-DENIES%% clocked asyncs.) A
%%OLIVIER-DENIES%% \xcd"ClockUseException"\index{clock!ClockUseException} is thrown
%%OLIVIER-DENIES%% if (and when) this condition is violated.
%%OLIVIER-DENIES%% 
%%OLIVIER-DENIES%% This is necessary to prevent deadlocks.  In the following invalid code 
%%OLIVIER-DENIES%% %~s~gen
%%OLIVIER-DENIES%% % package Activities.Finish.Hates.Clocks;
%%OLIVIER-DENIES%% % class Example{
%%OLIVIER-DENIES%% % def example() {
%%OLIVIER-DENIES%% %~s~vis
%%OLIVIER-DENIES%% \begin{xten}
%%OLIVIER-DENIES%% val c:Clock = Clock.make();
%%OLIVIER-DENIES%% async clocked(c) {                // (A) 
%%OLIVIER-DENIES%%       finish async clocked(c) {   // (B) INVALID
%%OLIVIER-DENIES%%             next;                 // (Bnext)
%%OLIVIER-DENIES%%       }
%%OLIVIER-DENIES%%       next;                       // (Anext)
%%OLIVIER-DENIES%% }
%%OLIVIER-DENIES%% \end{xten}
%%OLIVIER-DENIES%% %~s~siv
%%OLIVIER-DENIES%% % } } 
%%OLIVIER-DENIES%% %~s~neg
%%OLIVIER-DENIES%% \xcd`(A)`, first of all, waits for the \xcd`finish` containing \xcd`(B)` to
%%OLIVIER-DENIES%% finish.  
%%OLIVIER-DENIES%% \xcd`(B)` will execute its \xcd`next` at \xcd`(Bnext)`, and then wait for all
%%OLIVIER-DENIES%% other activities registered on \xcd`c` to execute their \xcd`next`s.
%%OLIVIER-DENIES%% However, \xcd`(A)` is registered on \xcd`c`.  So, \xcd`(B)` cannot finish
%%OLIVIER-DENIES%% until \xcd`(A)` has proceeded to \xcd`(Anext)`, and \xcd`(A)` cannot proceed
%%OLIVIER-DENIES%% until \xcd`(B)` finishes. Thus, this causes deadlock.
%%OLIVIER-DENIES%% 
%%OLIVIER-DENIES%% 
%%OLIVIER-DENIES%% 
%%OLIVIER-DENIES%% In \XtenCurrVer{} this condition is checked dynamically; future
%%OLIVIER-DENIES%% versions of the language will introduce type qualifiers which permit
%%OLIVIER-DENIES%% this condition to be checked statically.
%%OLIVIER-DENIES%% 
%%OLIVIER-DENIES%% \futureext{
%%OLIVIER-DENIES%% The semantics of \xcd"finish S" is conjunctive; it terminates when all
%%OLIVIER-DENIES%% the activities created during the execution of \xcd"S" (recursively)
%%OLIVIER-DENIES%% terminate. In many situations (e.g., nondeterministic search) it is
%%OLIVIER-DENIES%% natural to require a statement to terminate when any {\em one} of the
%%OLIVIER-DENIES%% activities it has spawned succeeds. The other activities may then be
%%OLIVIER-DENIES%% safely aborted. Future versions of the language may introduce a
%%OLIVIER-DENIES%% \xcd"finishone S" construct to support such speculative or nondeterministic
%%OLIVIER-DENIES%% computation.
%%OLIVIER-DENIES%% }
%%OLIVIER-DENIES%% 



\section{Initial activity}\label{initial-computation}\index{initial activity}

An \Xten{} computation is initiated from the command line on the
presentation of a classname \xcd"C". The class must have a
\xcd"public static def main(a: Rail[String]):Void" method, otherwise an
exception is thrown
and the computation terminates.  The single statement
\begin{xten}
finish async (Place.FIRST_PLACE) {
  C.main(s);
}
\end{xten} 
\noindent is executed where \xcd"s" is an Rail of strings created
from the command line arguments. This single activity is the root activity
for the entire computation. (See \Sref{XtenPlaces} for a discussion of
places.)

%% Say something about configuration information? 




\section{Ateach statements}\index{\Xcd{ateach}}\label{ateach-section}

\begin{grammar}
Statement \: AtEachStatement \\
AtEachStatement \:
      \xcd"ateach" \xcd"(" Formal \xcd"in" Expression \xcd")"
         Statement \\
AtEachStatement \:
      \xcd"ateach" \xcd"(" Expression \xcd")"
         Statement 
\end{grammar}

The \xcd"ateach" statement \xcd`ateach (p in D) S`
spawns an activity \xcd`S` at each place \xcd`p` of a distribution \xcd`D`. 
In \xcd`ateach(p in D) S`, 
\xcd`D` must be either of type \xcd"Dist" 
(see \Sref{XtenDistributions})
or of type
\xcd`DistArray[T]` (see \Sref{XtenArrays}), 
and \xcd`p` will be of type \xcd"Point" (see \Sref{point-syntax}).

\xcd`ateach(p in D)S` is equivalent to 
\xcd`for(p in D) at(D(p)) async S`.  That is, the elements of \xcd`D` are all
points \xcd`p`.  \xcd`D(p)` is a \xcd`Place`.  \xcd`ateach(p in D)S` executes
the body \xcd`S` at the place \xcd`D(p)` (and may use the point \xcd`p`
there). 


However, the compiler may implement it more efficiently to avoid extraneous
communications.  In particular, it is recommended that \xcd`ateach(p in D)S`
be implemented as the following code, which coordinates with each place of
\xcd`D` just once, rather than once per element of \xcd`D` at that place: 

%~~gen
% package Activities.Activities.Activities;
% class EquivCode {
% static def S(pt:Point) {}
% static def example(D:Dist) {
%~~vis
\begin{xten}
for (p in D.places()) async at (p) {
    for (pt in D|here) async {
        S(pt);
    }
}
\end{xten}
%~~siv
%}} 
%~~neg

If \xcd`e` is an \xcd`DistArray[T]`, then \xcd`ateach (p in e)S` is identical to
\xcd`ateach(p in e.dist)S`; the iteration is over the array's underlying
distribution.   
The code below is a common and generally efficient way to work with the
elements of a distributed array:
%~~gen
%package Activities.For.Fnu.And.Pforit;
%class Example[T]{
%  def dealWith(T):Void = {}
% def idiom(A:DistArray[T]){
%~~vis
\begin{xten}
ateach(p in A) 
  dealWith(A(p));
\end{xten}
%~~siv
%}}
%~~neg








\section{At expressions}

\begin{grammar}
Expression \: \xcd"at" \xcd"(" Expression \xcd")" Expression
\end{grammar}

An \Xcd{at} expression evaluates an expression synchronously at the
given place and returns its value.  For instance a copy of the
value pointed to by a \Xcd{GlobalRef} may be obtained using
the \Xcd{fetch} method:
%~~gen
% package Activities.AtExpressions.Fetching;
% class Example[T] {
%~~vis
\begin{xten}
  def fetch(g:GlobalRef[T]):T = at (g) g();
\end{xten}
%~~siv
% } 
%~~neg

The expression evaluation may spawn asynchronous activities. The \Xcd{at}
expression will return without waiting for those activities to terminate. That
is, \Xcd{at} does not have built-in \Xcd{finish} semantics.

\section{Atomic blocks}\label{AtomicBlocks}\index{atomic blocks}
Languages such as \java{} use low-level synchronization locks to allow
multiple interacting threads to coordinate the mutation of shared
data. \Xten{} eschews locks in favor of a very simple high-level
construct, the {\em atomic block}.

A programmer may use atomic blocks to guarantee that invariants of
shared data-structures are maintained even as they are being accessed
simultaneously by multiple activities running in the same place.  

For example, consider a class \xcd`Redund[T]`, which encapsulates a list
\xcd`list` and, (redundantly) keeps the size of the list in a second field
\xcd`size`.  Then \xcd`r:Redund[T]` has the invariant 
\xcd`r.list.size() == r.size`, which must be true at any point that there are
no method calls on \xcd`r` active.

If the \xcd`add` method on \xcd`Redund` (which adds an element to the list) 
were defined as: 
%~~gen
% package Activities.Atomic.Redund.One;
% import x10.util.*;
% class Redund[T] {
%   val list = new ArrayList[T]();
%   var size : Int = 0;
%~~vis
\begin{xten}
def add(x:T) { // Incorrect
  this.list.add(x);
  this.size = this.size + 1;
}
\end{xten}
%~~siv
%}
%~~neg
Then two activities simultaneously adding elements to the same \xcd`r` could break the
invariant.  Suppose that \xcd`r` starts out empty.  Let the first activity
perform the \xcd`list.add`, and compute \xcd`this.size+1`, which is 1, but not store it
back into \xcd`this.size` yet.  
(At this point, \xcd`r.list.size()==1` and \xcd`r.size==0`; the invariant
expression is false, but, as the first call to \xcd`r.add()` is active, the
invariant does not need to be true -- it only needs to be true when the
call finishes.)
Now, let the second activity do its call to
\xcd`add` to completion, which finishes with \xcd`r.size==1`.  
(As before, the invariant expression is false, but a call to \xcd`r.add()` is
still active, so the invariant need not be true.)
Finally, let
the first activity finish, which assigns the \xcd`1` computed before back into
\xcd`this.size`.  At the end, there are two elements in \xcd`r.list`, but
\xcd`r.size==1`. Since there are no calls to \xcd`r.add()` active, the
invariant must be true, but it is not.

In this case, the invariant can be maintained by making the increment atomic.
Doing so forbids that sequence of events; the \xcd`atomic` block cannot be
stopped partway.  
%~~gen
% package Activities.Atomic.Redund.Two;
% import x10.util.*;
% class Redund[T] {
%   val list = new ArrayList[T]();
%   var size : Int = 0;
%~~vis
\begin{xten}
def add(x:T) { 
  this.list.add(x);
  atomic { this.size = this.size + 1; }
}
\end{xten}
%~~siv
%}
%~~neg



\subsection{Unconditional atomic blocks}
The simplest form of an atomic block is the {\em unconditional
atomic block}:

\begin{grammar}
Statement \: AtomicStatement \\
AtomicStatement \: \xcd"atomic"  Statement \\
MethodModifier \: \xcd"atomic" \\
\end{grammar}

%%NOW-DYN%% For the sake of efficient implementation \XtenCurrVer{} requires
%%NOW-DYN%% that the atomic block be {\em analyzable}, that is, the set of
%%NOW-DYN%% locations that are read and written by the \grammarrule{BlockStatement} are
%%NOW-DYN%% bounded and determined statically.\footnote{A static bound is a constant
%%NOW-DYN%% that depends only on the program text, and is independent 
%%NOW-DYN%% of any runtime parameters. }
%%NOW-DYN%% The exact algorithm to be used by
%%NOW-DYN%% the compiler to perform this analysis will be specified in future
%%NOW-DYN%% versions of the language.
%%NOW-DYN%% \tbd{}

Such a statement is executed by an activity as if in a single step
during which all other concurrent activities in the same place are
blocked. If execution of the statement may throw an exception, it is
the programmer's responsibility to wrap the atomic block within a
\xcd"try"/\xcd"finally" clause and include undo code in the finally
clause. Thus the \xcd"atomic" statement only guarantees atomicity on
successful execution, not on a faulty execution.


We allow methods of an object to be annotated with \xcd"atomic". Such
a method is taken to stand for a method whose body is wrapped within an
\xcd"atomic" statement.

\noo{Finish checking this!  Note dynamic checks!}

Atomic blocks are closely related to non-blocking synchronization
constructs \cite{herlihy91waitfree}, and can be used to implement 
non-blocking concurrent algorithms.


In \xcd"atomic S", \xcd"S" may include calls to \xcd`safe` methods, and use of
sequential control structures.

It may {\em not} include an \xcd"async" activity (such as creation
of a \Xcd{future}).

It may {\em not} include any statement that may potentially block at
runtime (\eg, \xcd"when", \xcd"force" operations, \xcd"next"
operations on clocks, \xcd"finish"). 

It may {\em not} include any \xcd`at` expressions or
statements. (Hence all locations accessed in the atomic block must
belong to the current place.)


The compiler checks for this condition by checking whether the statement
could be the body of a \xcd"void" method annotated with \xcd"safe" at
that point in the code (\Sref{SafeAnnotation}).

\paragraph{Consequences.}
Note an important property of an (unconditional) atomic block:

\begin{eqnarray}
 \mbox{\xcd"atomic \{s1; atomic s2\}"} &=& \mbox{\xcd"atomic \{s1; s2\}"}
\end{eqnarray}

Atomic blocks do not introduce deadlocks.    They may exhibit all the bad
behavior of sequential programs, including throwing exceptions and running
forever, but they are guaranteed not to deadlock.


\subsubsection{Example}

The following class method implements a (generic) compare and swap (CAS) operation:


%~~gen
% package Activities.And.Protein;
% class CASSizer{
%~~vis
\begin{xten}
var target:Object = null;
public atomic def CAS(old1: Object, new1: Object): Boolean {
   if (target.equals(old1)) {
     target = new1;
     return true;
   }
   return false;
}
\end{xten}
%~~siv
%}
%~~neg

\subsection{Conditional atomic blocks}

Conditional atomic blocks allow the activity to wait for some condition to be
satisfied before executing an atomic block. For example, consider a
\xcd`Redund` class holding a list \xcd`r.list` and, redundantly, its length
\xcd`r.size`.  A \xcd`pop` operation will delay until the \xcd`Redund` is
nonempty, and then remove an element and update the length.  
%~~gen
% package Activities.Condato.Example.Not.A.Tree;
% import x10.util.*;
% class Redund[T] {
% val list = new ArrayList[T]();
% var size : Int = 0;
%~~vis
\begin{xten}
def pop():T {
  var ret : T;
  when(size>0) {
    ret = list.removeAt(0);
    size --;
    }
  return ret;
}
\end{xten}
%~~siv
% }
%~~neg


The execution of the test is atomic with the execution of the block.  This is
important; it means that no other activity can sneak in and make the condition
be false before the block is executed.  In this example, two \xcd`pop`s
executing on a list with one element would work properly. Without the
conditional atomic block -- even doing the decrement atomically -- one call to
\xcd`pop` could pass the \xcd`size>0` guard; then the other call could run to
completion (removing the only element of the list); then, when the first call
proceeds, its \xcd`removeAt` will fail.  

Note that \xcd`if` would not work here.  
\xcd`if(size>0) atomic{size--; return list.removeAt(0);}` allows another
activity to act between the test and the atomic block.  
And 
\xcd`atomic{ if(size>0) {size--; ret = list.removeAt(0);}}` 
does not wait for \xcd`size>0` to become true.


Conditional atomic blocks are of the form:

\begin{grammar}
Statement \:  WhenStatement \\
WhenStatement \:  \xcd"when" \xcd"(" Expression \xcd")" Statement \\
            \| WhenStatement \xcd"or" \xcd"(" Expression \xcd")" Statement 
\end{grammar}

In such a statement the one or more expressions are called {\em
guards} and must be \xcd"Boolean" expressions. The statements are the
corresponding {\em guarded statements}.  

An activity executing such a statement suspends until such time as any
one of the guards is true in the current state. In that state, the
statement corresponding to the first guard that is true is executed.
The checking of the guards and the execution of the corresponding
guarded statement is done atomically. 

\Xten{} does not guarantee that a conditional atomic block
will execute if its condition holds only intermittently. For, based on
the vagaries of the scheduler, the precise instant at which a
condition holds may be missed. Therefore the programmer is advised to
ensure that conditions being tested by conditional atomic blocks are
eventually stable, \ie, they will continue to hold until the block
executes (the action in the body of the block may cause the condition
to not hold any more).

%%Fourth, \Xten{} does not guarantees only {\em weak fairness} when executing
%%conditional atomic blocks. Let $c$ be the guard of some conditional
%%atomic block $A$. $A$ is required to make forward progress only if
%%$c$ is {\em eventually stable}. That is, any execution $s_1, s_2,
%%\ldots$ of the program is considered illegal only if there is a $j$
%%such that $c$ holds in all states $s_k$ for $k > j$ and in which $A$
%%does not execute. Specifically, if the system executes in such a way
%%that $c$ holds only intermmitently (that is, for some state in which
%%$c$ holds there is always a later state in which $c$ does not hold),
%%$A$ is not required to be executed (though it may be executed).

\begin{rationale}
The guarantee provided by \xcd"wait"/\xcd"notify" in \java{} is no
stronger. Indeed conditional atomic blocks may be thought of as a
replacement for \java's wait/notify functionality.
\end{rationale} 


The statement \xcd"when (true) S" is
behaviorally identical to \xcd"atomic S": it never suspends.

\begin{staticrule*}
For the sake of efficient implementation certain restrictions are
placed on the guards and statements in a conditional atomic
block. 
\end{staticrule*}

Guards are statically required not to have side-effects, not to spawn
asynchronous activities (as for the \xcd`sequential` qualifier on methods) and
to have a statically determinable upper bound on their execution (as for the
\xcd`nonblocking` qualifier on methods).

The body of a \xcd"when" statement must satisfy the conditions
for the body of an \xcd"atomic" block.

Note that this implies that guarded statements are required to be {\em
flat}, that is, they may not contain conditional atomic blocks. (The
implementation of nested conditional atomic blocks may require
sophisticated operational techniques such as rollbacks.)


\begin{example}
The following class shows how to implement a bounded buffer of size
$1$ in \Xten{} for repeated communication between a sender and a
receiver.  The call \xcd`buf.send(ob)` waits until the buffer has space, and
then puts \xcd`ob` into it.  Dually, \xcd`buf.receive()` waits until the
buffer has something in it, and then returns that thing.


%~~gen
% package Activities;
%~~vis
\begin{xten}
class OneBuffer[T] {
  var datum: T;
  def this(t:T) { this.datum = t; this.filled = true; }
  var filled: Boolean;
  public def send(v: T) {
    when (!filled) {
      this.datum = v;
      this.filled = true;
    }
  }
  public def receive(): T {
    when (filled) {
      v: T = datum;
      filled = false;
      return v;
    }
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{example}

