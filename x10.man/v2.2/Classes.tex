\chapter{Classes}
\label{XtenClasses}\index{class}
\label{ReferenceClasses}

\section{Principles of X10 Objects}\label{XtenObjects}\index{object}
\index{class}

\subsection{Basic Design}

Objects are instances of classes: the most common and most powerful sort of
value in X10.  The other kinds of values, structs and functions, are more
specialized, better in some circumstances but not in all.
\xcd"x10.lang.Object" is the most general class; all other classes inherit
from it, directly or indirectly. 


Classes are structured in a single-inheritance code
hierarchy.   They may have any or all of these features: 
\begin{itemize}
\item Implementing any number of interfaces;
\item Static and instance \xcd`val` fields; 
\item Instance \xcd`var` fields; 
\item Static and instance methods;
\item Constructors;
\item Properties;
\item Static and instance nested containers.
\end{itemize}


\Xten{} objects (unlike Java objects) do not have locks associated with them.
Programmers may use atomic blocks (\Sref{AtomicBlocks}) for mutual
exclusion and clocks (\Sref{XtenClocks}) for sequencing multiple parallel
operations.

An object exists in a single location: the place that it was created.  One
place cannot use or even directly refer to an object in a different place.   A
special type, \Xcd{GlobalRef[T]}, allows explicit cross-place references. 

The basic operations on objects are:
\begin{itemize}

{}\item Field access (\Sref{FieldAccess}). 
The static, instance, and property fields of an object can be retrieved; \xcd`var` fields
can be set.  

{}\item Method invocation (\Sref{MethodInvocation}).  
Static, instance, and property methods of an object can be invoked.

{}\item Casting (\Sref{ClassCast}) and instance testing with \xcd`instanceof`
(\Sref{instanceOf}) Objects can be cast or type-tested.  

\item The equality operators \xcd"==" and \xcd"!=".  
Objects can be compared for equality with the \Xcd{==} operation.  This checks
object {\em identity}: two objects are \Xcd{==} iff they are the same object.

\end{itemize}

  

\subsection{Class Declaration Syntax}

The {\em class declaration} has a list of type parameters, a list of
properties, a constraint (the {\em class invariant}), a single superclass,
zero or more interfaces that it implements, and a class body containing the
the definition of fields, properties, methods, and member types. Each such
declaration introduces a class type (\Sref{ReferenceTypes}).

%##(NormalClassDecl TypeParamsI TypeParamIList Properties PropertyList Property Guard Super Interfaces InterfaceTypeList ClassBody ClassBodyDecls ClassMemberDecl
\begin{bbgrammar}
%(FROM #(prod:NormalClassDecl)#)
     NormalClassDecl \: Mods\opt \xcd"class" Id TypeParamsI\opt Properties\opt Guard\opt Super\opt Interfaces\opt ClassBody & (\ref{prod:NormalClassDecl}) \\
%(FROM #(prod:TypeParamsI)#)
         TypeParamsI \: \xcd"[" TypeParamIList \xcd"]" & (\ref{prod:TypeParamsI}) \\
%(FROM #(prod:TypeParamIList)#)
      TypeParamIList \: TypeParamI & (\ref{prod:TypeParamIList}) \\
                     \| TypeParamIList \xcd"," TypeParamI \\
%(FROM #(prod:Properties)#)
          Properties \: \xcd"(" PropertyList \xcd")" & (\ref{prod:Properties}) \\
%(FROM #(prod:PropertyList)#)
        PropertyList \: Property & (\ref{prod:PropertyList}) \\
                     \| PropertyList \xcd"," Property \\
%(FROM #(prod:Property)#)
            Property \: Annotations\opt Id ResultType & (\ref{prod:Property}) \\
%(FROM #(prod:Guard)#)
               Guard \: DepParams & (\ref{prod:Guard}) \\
%(FROM #(prod:Super)#)
               Super \: \xcd"extends" ClassType & (\ref{prod:Super}) \\
%(FROM #(prod:Interfaces)#)
          Interfaces \: \xcd"implements" InterfaceTypeList & (\ref{prod:Interfaces}) \\
%(FROM #(prod:InterfaceTypeList)#)
   InterfaceTypeList \: Type & (\ref{prod:InterfaceTypeList}) \\
                     \| InterfaceTypeList \xcd"," Type \\
%(FROM #(prod:ClassBody)#)
           ClassBody \: \xcd"{" ClassBodyDecls\opt \xcd"}" & (\ref{prod:ClassBody}) \\
%(FROM #(prod:ClassBodyDecls)#)
      ClassBodyDecls \: ClassBodyDecl & (\ref{prod:ClassBodyDecls}) \\
                     \| ClassBodyDecls ClassBodyDecl \\
%(FROM #(prod:ClassMemberDecl)#)
     ClassMemberDecl \: FieldDecl & (\ref{prod:ClassMemberDecl}) \\
                     \| MethodDecl \\
                     \| PropertyMethodDecl \\
                     \| TypeDefDecl \\
                     \| ClassDecl \\
                     \| InterfaceDecl \\
                     \| \xcd";" \\
\end{bbgrammar}
%##)




\section{Fields}
\label{FieldDefinitions}
\index{object!field}
\index{field}

Objects may have {\em instance fields}, or simply {\em fields} (called
``instance variables'' in C++ and Smalltalk, and ``slots'' in CLOS): places to
store data that is pertinent to the object.  Fields, like variables, may be
mutable (\xcd`var`) or immutable (\xcd`val`).  

Class may have {\em static fields}, which store data pertinent to the
entire class of objects.  
See \Sref{StaticInitialization} for more information.

No two fields of the same class may have the same name.  A field may have the
same name as a method, although for fields of functional type there is a
subtlety (\Sref{sect:disambiguations}).  

\subsection{Field Initialization}
\index{field!initialization}
\index{initialization!of field}

Fields may be given values via {\em field initialization expressions}:
\xcd`val f1 = E;` and \xcd`var f2 : Int = F;`. Other fields of \xcd`this` may
be referenced, but only those that {\em precede} the field being initialized.


\begin{ex}The following is correct, but would not be if the fields were
reversed:

%~~gen ^^^ Classes10
%package Classes_field_init_expr_a;
%~~vis
\begin{xten}
class Fld{
  val a = 1;
  val b = 2+a;
}
\end{xten}
%~~siv
% class Hook{ def run() {
%   val f = new Fld();
%   assert f.a == 1 && f.b == 3;
%   return true;}}
%~~neg
\end{ex}

\subsection{Field hiding}
\index{field!hiding}


A subclass that defines a field \xcd"f" hides any field \xcd"f"
declared in a superclass, regardless of their types.  The
superclass field \xcd"f" may be accessed within the body of
the subclass via the reference \xcd"super.f".

With inner classes, it is occasionally necessary to 
write \xcd`Cls.super.f` to get at a hidden field \xcd`f` of an outer class
\xcd`Cls`. 

\begin{ex}
The \xcd`f` field in \xcd`Sub` hides the \xcd`f` field in \xcd`Super`
The \xcd`superf` method provides access to the \xcd`f` field in \xcd`Super`.
%~~gen ^^^ Classes20
% package classes.fields.primus;
%~~vis
\begin{xten}
class Super{ 
  public val f = 1; 
}
class Sub extends Super {
  val f = true;
  def superf() : Int = super.f; // 1
}
\end{xten}
%~~siv
% class Hook { def run() { 
%   val sub = new Sub();
%   assert sub.f == true;
%   assert sub.superf() == 1;
%   return true;} }
%~~neg
\end{ex}

\begin{ex}
Hidden fields of outer classes can be accessed by suitable forms: 
%~~gen ^^^ Classes30
% package classes.fields.secundus; 
% NOTEST
%~~vis
\begin{xten}
class A {
   val f = 3;
}
class B extends A {
   val f = 4;
   class C extends B {
      // C is both a subclass and inner class of B
      val f = 5;
       def example() {
         assert f         == 5 : "field of C";
         assert super.f   == 4 : "field of superclass";
         assert B.this.f  == 4 : "field of outer instance";
         assert B.super.f == 3 : "super.f of outer instance";
       }
    }
}
\end{xten}
%~~siv
% class Hook { def run() { ((new B()).new C()).example(); return true; } }
%~~neg
\end{ex}

\subsection{Field qualifiers}
\label{FieldQualifier}
\index{qualifier!field}
\index{field!qualifier}

The behavior of a field may be changed by a field qualifier, such as
\xcd`static` or \xcd`transient`.  


\subsubsection{\Xcd{static} qualifier}
\index{field!static}

A \xcd`val` field may be declared to be {\em static}, as described in
\Sref{FieldDefinitions}. 

\subsubsection{\Xcd{transient} Qualifier}
\label{TransientFields}
\index{transient}
\index{field!transient}

A field may be declared to be {\em transient}.  Transient fields are excluded
from the deep copying that happens when information is sent from place to
place in an \Xcd{at} statement.    The value of a transient field of a copied
object is the default value of its type, regardless of the value of the field
in the original.  If the type of a field has no
default value, it cannot be marked \Xcd{transient}.

%%AT-COPY%% %~~gen ^^^ Classes40
%%AT-COPY%% % package Classes.Transient.Example;
%%AT-COPY%% % KNOWNFAIL-at
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% class Trans { 
%%AT-COPY%%    val copied = "copied";
%%AT-COPY%%    transient var transy : String = "a very long string";
%%AT-COPY%%    def example() {
%%AT-COPY%%       at (here; this) { // causes copying of 'this'
%%AT-COPY%%          assert(this.copied.equals("copied"));
%%AT-COPY%%          assert(this.transy == null);
%%AT-COPY%%       }
%%AT-COPY%%    }
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% % class Hook{ def run() {(new Example()).example(); return true;}}
%%AT-COPY%% %~~neg
%%AT-COPY%% 

%~~gen ^^^ Classes40
% package Classes.Transient.Example;
% 
%~~vis
\begin{xten}
class Trans { 
   val copied = "copied";
   transient var transy : String = "a very long string";
   def example() {
      at (here) { // causes copying of 'this'
         assert(this.copied.equals("copied"));
         assert(this.transy == null);
      }
   }
}
\end{xten}
%~~siv
% class Hook{ def run() {(new Trans()).example(); return true;}}
%~~neg


\section{Properties}
\label{PropertiesInClasses}
\index{property}

The properties of an object (or struct) are  public \xcd`val` fields
usable at compile time in constraints.\footnote{In many cases, a 
\xcd`val` field can be upgraded to a \xcd`property`, which 
entails no compile-time or runtime cost.  Some cannot be, \eg, in cases where
cyclic structures of \xcd`val` fields are required.} 
For example,  every array has a \xcd`rank` telling
how many subscripts it takes.  User-defined classes can have whatever
properties are desired. 

Properties are defined in parentheses, after the name of the class.  They are
given values by the \xcd`property` command in constructors.

\begin{ex}
\xcd`Proper` has a single property, \xcd`t`.  \xcd`new Proper(4)` creates a
\xcd`Proper` object with \xcd`t==4`. 
%~~gen ^^^ Classes50
% package Classes.Toss.Freedom.Disk2;
%~~vis
\begin{xten}
class Proper(t:Int) {
  def this(t:Int) {property(t);}
}
\end{xten}
%~~siv
% class Hook{ def run() {
%   val p = new Proper(4);
%   return p.t == 4;
% } } 
%~~neg

\end{ex}


It is a static error for a class
defining a property \xcd"x: T" to have a subclass class that defines
a property or a field with the name \xcd"x".


A property \xcd`x:T` induces a field with the same name and type, 
as if defined with: 
%~~gen ^^^ Classes60
% package Classes.For.Masses.Of.NevermindTheRest;
% class Exampll[T] {
%~~vis
\begin{xten}
public val x : T;
\end{xten} 
%~~siv
% def this(y:T) { x=y; }
% }
%~~neg
\noindent It also defines a nullary getter method, 
%~~gen ^^^ Classes70
% package Classes_nullary_getter_a;
% class Exampllll[T] {
% public val x : T;
% def this(y:T) { x=y; }
%~~vis
\begin{xten}
public final def x()=x;
\end{xten}
%~~siv
%}
%~~neg





\index{property!initialization}
Properties are initialized in a constructor by the invocation of a special \Xcd{property}
statement. The requirement to use the \xcd`property` statement means that all properties
must be given values at the same time: a container either has its properties
or it does not.
\begin{xten}
property(e1,..., en);
\end{xten}
The number and types of arguments to the \Xcd{property} statement must match
the number and types of the properties in the class declaration, in order.  
Every constructor of a class with properties must invoke \xcd`property(...)`
precisely once; it is a static error if X10 cannot prove that this holds.



By construction, the graph whose nodes are values and whose edges are
properties is acyclic.  \Eg, there cannot be values \xcd`a` and \xcd`b` with
properties \xcd`c` and \xcd`d` such that \xcd`a.c == b` and \xcd`b.d == a`.

\begin{ex}
%~~gen ^^^ Classes7h2f
% package Classes7h2f;
%~~vis
\begin{xten}
class Proper(a:Int, b:String) {
  def this(a:Int, b:String) {
      property(a, b);
  }
  def this(z:Int) {
      val theA = z+5;
      val theB = "X"+z;
      property(theA, theB);
  }
  static def example() {
      val p = new Proper(1, "one");
      assert p.a == 1 && p.b.equals("one");
      val q = new Proper(10);
      assert q.a == 15 && q.b.equals("X10");
  }
}
\end{xten}
%~~siv
% class Hook{ def run() {Proper.example(); return true;}}
%~~neg

\end{ex}

\subsection{Properties and Fields}

A container with a property named \xcd`p`, or a nullary property method named
\xcd`p()`, cannot have a field named \xcd`p` --- either defined in that
container, or inherited from a superclass.

\subsection{Acyclicity of Properties}
\index{properties!acyclic}

X10 has certain restrictions that, ultimately, require that properties are
simpler than their containers.  For example, \xcd`class A(a:A){}` is not
allowed.  
Formally, this requirement is that there is  a total order $\preceq$ 
on all classes and
structs such that, if $A$ extends $B$, then $A \prec B$, and
if $A$ has a property of type $B$, then $A \prec B$, where $A \prec B$ means
$A \preceq B$ and $A \ne B$.   
For example, the preceding class \xcd`A` is ruled out because we would need
\xcd`A`$\prec$\xcd`A`, which violates the definition of $\prec$.
The programmer need not (and cannot) specify
$\preceq$, and rarely need worry about its existence.  

Similarly, 
the type of a property may not simply be a type parameter.  
For example, \xcd`class A[X](x:X){}` is illegal.





\section{Methods}
\index{method}
\index{signature}
\index{method!signature}
\index{method!instance}
\index{method!static}

As is common in object-oriented languages, objects can have {\em methods}, of
two sorts.  {\em Static methods} are functions, conceptually associated with a
class and defined in its namespace.  {\em Instance methods} are parameterized
code bodies associated with an instance of the class, which execute with
convenient access to that instance's fields. 

Each method has a {\em signature}, telling what arguments it accepts, what
type it returns, and what precondition it requires. Method definitions may be
overridden by subclasses; the overriding definition may have a declared return
type that is a subtype of the return type of the definition being overridden.
Multiple methods with the same name but different signatures may be provided
\index{overloading}
\index{polymorphism}
on a class (called ``overloading'' or ``ad hoc polymorphism''). Methods may be
declared \Xcd{public}, \Xcd{private}, \Xcd{protected}, or given default package-level access
rights.

%##(MethMods MethodDecl TypeParams Formals FormalList HasResultType MethodBody
\begin{bbgrammar}
%(FROM #(prod:MethMods)#)
            MethMods \: Mods\opt & (\ref{prod:MethMods}) \\
                     \| MethMods \xcd"property"  \\
                     \| MethMods Mod \\
%(FROM #(prod:MethodDecl)#)
          MethodDecl \: MethMods \xcd"def" Id TypeParams\opt Formals Guard\opt HasResultType\opt Offers\opt MethodBody & (\ref{prod:MethodDecl}) \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" BinOp \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt PrefixOp \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"this" BinOp \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" BinOp \xcd"this" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt PrefixOp \xcd"this" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" \xcd"this" TypeParams\opt Formals Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" \xcd"this" TypeParams\opt Formals \xcd"=" \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" \xcd"as" Type Guard\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" \xcd"as" \xcd"?" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
%(FROM #(prod:TypeParams)#)
          TypeParams \: \xcd"[" TypeParamList \xcd"]" & (\ref{prod:TypeParams}) \\
%(FROM #(prod:Formals)#)
             Formals \: \xcd"(" FormalList\opt \xcd")" & (\ref{prod:Formals}) \\
%(FROM #(prod:FormalList)#)
          FormalList \: Formal & (\ref{prod:FormalList}) \\
                     \| FormalList \xcd"," Formal \\
%(FROM #(prod:HasResultType)#)
       HasResultType \: \xcd":" Type & (\ref{prod:HasResultType}) \\
                     \| \xcd"<:" Type \\
%(FROM #(prod:MethodBody)#)
          MethodBody \: \xcd"=" LastExp \xcd";" & (\ref{prod:MethodBody}) \\
                     \| \xcd"=" Annotations\opt \xcd"{" BlockStatements\opt LastExp \xcd"}" \\
                     \| \xcd"=" Annotations\opt Block \\
                     \| Annotations\opt Block \\
                     \| \xcd";" \\
\end{bbgrammar}
%##)


\index{parameter!var}
\index{parameter!val}
A formal parameter may have a \xcd"val" or \xcd"var"
% , or \Xcd{ref}
modifier; \xcd`val` is the default.
The body of the method is executed in an environment in which 
each formal parameter corresponds to a local variable (\xcd`var` iff the
formal parameter is \xcd`var`)
and is initialized with the value of the actual parameter.

\subsection{Forms of Method Definition}

There are several syntactic forms for definining methods.   The forms that
include a block, such as \xcd`def m(){S}`, allow an arbitrary block.  These
forms can define a \xcd`void` method, which does not return a value. 

The
forms that include an expression, such as \xcd`def m()=E`, require a
syntactically and semantically valid expression.   These forms cannot define a
\xcd`void` method, because expressions cannot be \xcd`void`.  

There are no other semantic differences between the two forms. 

\subsection{Final Methods}
\index{final}
\index{method!final}
An instance method may be given the \xcd`final` qualifier.  \xcd`final`
methods may not be overridden.

\subsection{Generic Instance Methods}
\index{method!generic instance}

\limitationx{}
In X10, an instance method may be generic: 
%~~gen ^^^ Classes1b7z
% package Classes1b7z;
% NOTEST
%~~vis
\begin{xten}
class Example {
  def example[T](t:T) = "I like " + t;
}
\end{xten}
%~~siv
%
%~~neg

However, the C++ back end does not currently support generic virtual instance
methods like \xcd`example`.  It does allow generic instance methods which are
\xcd`final` or \xcd`private`, and it does allow generic static methods.  


\subsection{Method Guards}
\label{MethodGuard}
\index{method!guard}
\index{guard!on method}

Often, a method will only make sense to invoke under certain
statically-determinable conditions.  These conditions may be expressed as a
guard on the method.

\begin{ex}
For example, \xcd`example(x)` is only
well-defined when \xcd`x != null`, as \xcd`null.toString()` throws a null
pointer exception: 
%~~gen ^^^ Classes80
% package Classes.methodwithconstraintthingie;
% 
%~~vis
\begin{xten}
class Example {
   var f : String = "";
   def setF(x:Object){x != null} = {
      this.f = x.toString();
   }
}
\end{xten}
%~~siv
%
%~~neg
\noindent
(We could have used a constrained type \xcd`Object{self!=null}` for \xcd`x`
instead; in
most cases it is a matter of personal preference or convenience of expression
which one to use.) 
\end{ex}


The requirement of having a method guard 
is that callers must demonstrate to
the X10
compiler that the guard is satisfied.  
With the \xcd`STATIC_CHECKS` compiler option in force (\Sref{sect:Callstyle}), this is
checked at compile time. 
As usual with static constraint
checking, there is no runtime cost.  Indeed, this code can be more efficient
than usual, as it is statically provable that \xcd`x != null`.

When \xcd`STATIC_CHECKS` is not in force, dynamic checks are generated as
needed; method guards are checked at runtime. This is potentially more
expensive, but may be more convenient. 

\begin{ex}
The following code fragment contains a line which will not compile 
with \xcd`STATIC_CHECKS` on (assuming the guarded \xcd`example` method above).  (X10's type system does not attempt to propagate 
information from \xcd`if`s.)  It will compile with \xcd`STATIC_CHECKS` off,
but it may insert an extra \xcd`null`-test for \xcd`x`.  
%~~gen ^^^ Classes90
% package Classes.methodguardnadacastthingie;
%//OPTIONS: -STATIC_CHECKS
% class Example {var f : String = ""; def example(x:Object){x != null} = {this.f = x.toString();}}
% class Eyample {
%~~vis
\begin{xten}
  def exam(e:Example, x:Object) {
    if (x != null) 
       e.example(x as Object{x != null});
       // If STATIC_CHECKS is in force: 
       // ERROR: if (x != null) e.example(x); 
  }
\end{xten}
%~~siv
%}
%~~neg
\end{ex}


The guard \xcd`{c}` 
in a guarded method 
\xcd`def m(){c} = E;`
specifies a constraint \xcd"c" on the
properties of the class \xcd"C" on which the method is being defined. The
method, in effect, only exists  for those instances of \xcd"C" which satisfy
\xcd"c".  It is 
illegal for code to invoke the method on objects whose static type is
not a subtype of \xcd"C{c}".

Specifically: 
    the compiler checks that every method invocation
    \xcdmath"o.m(e$_1$, $\dots$, e$_n$)"
    is type correct. Each argument
    \xcdmath"e$_i$" must have a
    static type \xcdmath"S$_i$" that is a subtype of the declared type
    \xcdmath"T$_i$" for the $i$th
    argument of the method, and the conjunction of the constraints on the
    static types 
    of the arguments must entail the guard in the parameter list
    of the method.

    The compiler checks that in every method invocation
    \xcdmath"o.m(e$_1$, $\dots$, e$_n$)"
    the static type of \xcd"o", \xcd"S", is a subtype of \xcd"C{c}", where the method
    is defined in class \xcd"C" and the guard for \xcd"m" is equivalent to
    \xcd"c".

    Finally, if the declared return type of the method is
    \xcd"D{d}", the
    return type computed for the call is
    \xcdmath"D{a: S; x$_1$: S$_1$; $\dots$; x$_n$: S$_n$; d[a/this]}",
    where \xcd"a" is a new
    variable that does not occur in
    \xcdmath"d, S, S$_1$, $\dots$, S$_n$", and
    \xcdmath"x$_1$, $\dots$, x$_n$" are the formal
    parameters of the method.


\limitation{
Using a reference to an outer class, \xcd`Outer.this`, in a constraint, is not supported.
}


\subsection{Property methods}
\index{method!property}
\index{property method}

%##(PropertyMethodDecl
\begin{bbgrammar}
%(FROM #(prod:PropertyMethodDecl)#)
  PropertyMethodDecl \: MethMods Id TypeParams\opt Formals Guard\opt HasResultType\opt MethodBody & (\ref{prod:PropertyMethodDecl}) \\
                     \| MethMods Id Guard\opt HasResultType\opt MethodBody \\
\end{bbgrammar}
%##)

Property methods are methods that can be evaluated in constraints, as
properties can.   They provide a means of abstraction over properties; \eg,
interfaces can specify property methods that implementing containers must
provide, but, just as they cannot specify ordinary fields, they cannot specify
property fields.   Property methods are very limited in computing power: they
must obey the same restrictions as constraint expressions.  In particular,
they cannot have side effects, or even much code in their bodies.


\begin{ex}
The \xcd`eq()` method below tells if the \xcd`x` and \xcd`y`
properties are equal; the \xcd`is(z)` method tells if they are both equal to
\xcd`z`.  
The \xcd`eq` and \xcd`is` property methods are used in types in the
\xcd`example` method.
%~~gen ^^^ Classes100
%package Classes.PropertyMethods;
%~~vis
\begin{xten}
class Example(x:Int, y:Int) {
   def this(x:Int, y:Int) { property(x,y); }
   property eq() = (x==y);
   property is(z:Int) = x==z && y==z;
   def example( a : Example{eq()}, b : Example{is(3)} ) {}
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

A property method declared in a class must have
a body and must not be \xcd"void".  The body of the method must
consist of only a single \xcd"return" statement with an expression,  or a single
expression.  It is a static error if the expression cannot be
represented in the constraint system.   Property methods may be \xcd`abstract`
in \xcd`abstract` classes, and may be specified in interfaces, but are
implicitly \xcd`final` in 
non-\xcd`abstract` classes. 

The expression may contain invocations of other property methods. It is the
responsibility of the programmer to ensure that the evaluation of a property
terminates at compile-time, otherwise the type-checker will not terminate and
the program will fail to compile in a potentially most unfortunate way.

Property methods in classes are implicitly \xcd"final"; they cannot be
overridden.  It is a static error if a superclass has a property method with a
given signature, and a subclass has a method or property method with the same
signature.   It is a static error if a superclass has a property with some
name \xcd`p`, and a subclass has a nullary method of any kind (instance,
static, or property) also named \xcd`p`. 



A nullary property method definition may omit 
the \xcd"def" keyword.  That is, the following are equivalent:

%~~gen ^^^ Classes110
% package classes.waifsome1;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%~~vis
\begin{xten}
property def rail(): Boolean = 
   rect && onePlace == here && zeroBased;
\end{xten}
%~~siv
%}
%~~neg
and
%~~gen ^^^ Classes120
% package classes.waifsome2;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%~~vis
\begin{xten}
property rail(): Boolean = 
   rect && onePlace == here && zeroBased;
\end{xten}
%~~siv
%}
%~~neg

Similarly, nullary property methods can be inspected in constraints without
\xcd`()`. If \xcd`ob`'s type has a property \xcd`p`, then \xcd`ob.p` is that
property. Otherwise, if it has a nullary property method \xcd`p()`, \xcd`ob.p`
is equivalent to \xcd`ob.p()`. As a consequence, if the type provides both a
property \xcd`p` and a nullary method \xcd`p()`, then the property can be
accessed as \xcd`ob.p` and the method as \xcd`ob.p()`.\footnote{This only
applies to nullary property methods, not nullary instance methods.  Nullary
property methods perform limited computations, have no side effects, and
always return the same value, since
they have to be expressed in the constraint sublanguage.  In this sense, a
nullary property method does not behave hugely different from a property.
indeed, a compilation scheme which cached the value of the property method
would all but erase the distinction.  Other methods may
have more behavior, \eg, side effects, so we keep the \xcd`()` to make it
clear that a method call is potentially large.
}

%~~longexp~~`~~` ^^^ Classes130
% package classes.not.weasels;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%   def this(rect:Boolean, onePlace:Place, zeroBased:Boolean) 
%          :Waif{self.rect==rect, self.onePlace==onePlace, self.zeroBased==zeroBased}
%          = {property(rect, onePlace, zeroBased);}
%   property rail(): Boolean = rect && onePlace == here && zeroBased;
%   static def zoink() {
%      val w : Waif{
%~~vis
\xcd`w.rail`, with either definition above, 
% }= new Waif(true, here, true);
% }}
%~~pxegnol
is equivalent to 
%~~longexp~~`~~` ^^^ Classes140
% package classes.not.ferrets;
% class Waif(rect:Boolean, onePlace:Place, zeroBased:Boolean) {
%   def this(rect:Boolean, onePlace:Place, zeroBased:Boolean) 
%          :Waif{self.rect==rect, self.onePlace==onePlace, self.zeroBased==zeroBased}
%          = {property(rect, onePlace, zeroBased);}
%   property rail(): Boolean = rect && onePlace == here && zeroBased;
%   static def zoink() {
%      val w : Waif{
%~~vis
\xcd`w.rail()`
% }= new Waif(true, here, true);
% }}
%~~pxegnol




\subsection{Method overloading, overriding, hiding, shadowing and obscuring}
\label{MethodOverload}
\index{method!overloading}



The definitions of method overloading, overriding, hiding, shadowing and
obscuring in \Xten{} are familiar from languages such as Java, modulo the
following considerations motivated by type parameters and dependent types.



Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have formal parameters of different constraint-erased types (in some instantiation of the
generic parameters). 



\begin{ex}
The following overloading of \xcd`m` is unproblematic.
%~~gen ^^^ Classes150
% package Classes.Mful;
%~~vis
\begin{xten}
class Mful{
   def m() = 1;
   def m[T]() = 2;
   def m(x:Int) = 3;
   def m[T](x:Int) = 4;
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}


A class definition may include methods which are ambiguous in {\em some}
generic instantiation. (It is a compile-time error if the methods are
ambiguous in {\em every} generic instantiation, but excluding class
definitions which are are ambiguous in {\em some} instantiation would exclude
useful cases.)  It is a compile-time error to {\em use} an ambiguous method
call. 

\begin{ex}
The following class definition is acceptable.  However, the marked method
calls are ambiguous, and hence not acceptable.
%~~gen ^^^ Classes4d5e
% package Classes4d5e;
%~~vis
\begin{xten}
class Two[T,U]{
  def m(x:T)=1;
  def m(x:Int)=2;
  def m[X](x:X)=3;
  def m(x:U)=4;
  static def example() {
    val t12 = new Two[Int, Any]();
    // ERROR: t12.m(2);
    val t13  = new Two[String, Any]();
    t13.m("ferret");
    val t14 = new Two[Boolean,Boolean]();
    // ERROR: t14.m(true);
  }
}
\end{xten}
%~~siv
%~~neg
\noindent
The call \xcd`t12.m(2)` could refer to either the \xcd`1` or \xcd`2`
definition of \xcd`m`, so it is not allowed.   
The call \xcd`t14.m(true)` could refer to either the \xcd`1` or \xcd`4`
definition, so it, too, is not allowed.

The call \xcd`t13.m("ferret")` refers only to the \xcd`1` definition.  If
the \xcd`1` definition were absent, type argument inference would make it
refer to the \xcd`3` definition.  However, X10 will choose a fully-specified
call if there is one, before trying type inference, so this call unambiguously
refers to \xcd`1`.
\end{ex}


\XtenCurrVer{} does not permit overloading based on constraints. That is, the
following is {\em not} legal, although either method definition individually
is legal:
\begin{xten}
   def n(x:Int){x==1} = "one";
   def n(x:Int){x!=1} = "not";
\end{xten}




The definition of a method declaration \xcdmath"m$_1$" ``having the same signature
as'' a method declaration \xcdmath"m$_2$" involves identity of types. 



The {\em constraint erasure} of a type \xcdmath"T", 
\xcdmath"$ce$(T)",
is obtained by removing all the constraints outside of functions in \xcd`T`,
specificially: 
\begin{eqnarray}
ce({\tt T}) &=& {\tt T} \mbox{ if \xcd`T` is a container or interface}\\
ce({\tt T\{c\}}) &=& ce({\tt T})\\
ce({\tt T[S}_1{\tt,}\ldots{\tt,S}_n{\tt ]})
  &=&
ce({\tt T}){\tt [} ce({\tt S}_1){\tt,}\ldots{\tt,} ce({\tt S}_n){\tt ]}\\
ce({\tt (S}_1{\tt,}\ldots{\tt,S}_n{\tt ) => T})
  &=&
{\tt }{\tt (} ce({\tt S}_1){\tt,}\ldots{\tt,} ce({\tt S}_n){\tt ) => } 
ce({\tt T})
\end{eqnarray}



 Two methods are said to have {\em equivalent signatures} if (a) they have the
 same number of type parameters, 
(b) they have the same number of formal (value) parameters, and (c)
for each formal parameter the constraint erasure of its types are equivalent.
It is a 
compile-time error for there to be two methods with the same name and
equivalent signatures in a class (either defined in that class or in a
superclass), unless the signatures are identical and one of the methods is
defined in a superclass (in which case the superclass's method is overridden
by the subclass's).

 



In addition, the guard of a overriding method
must entail
the guard of the overridden method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.


  If a class \xcd"C" overrides a method of a class or interface
  \xcd"B", the guard of the method in \xcd"B" must entail
  the guard of the method in \xcd"C".


A class \xcd"C" inherits from its direct superclass and superinterfaces all
their methods visible according to the access modifiers
of the superclass/superinterfaces that are not hidden or overridden. A method \xcdmath"M$_1$" in a class
\xcd"C" overrides
a method \xcdmath"M$_2$" in a superclass \xcd"D" if
\xcdmath"M$_1$" and \xcdmath"M$_2$" have equivalent signatures.
Methods are overriden on a signature-by-signature basis.  It is a compile-time
error if an instance method overrides a static method.  (But is it permitted
for an instance {\em field} to hide a static {\em field}; that's hiding, not
overriding, and hence totally different.)

\section{Constructors}
\label{sect:constructors}
\index{constructor}

Instances of classes are created by the \xcd`new` expression: \\
%##(ClassInstCreationExp
\begin{bbgrammar}
%(FROM #(prod:ClassInstCreationExp)#)
ClassInstCreationExp \: \xcd"new" TypeName TypeArgs\opt \xcd"(" ArgumentList\opt \xcd")" ClassBody\opt & (\ref{prod:ClassInstCreationExp}) \\
                     \| Primary \xcd"." \xcd"new" Id TypeArgs\opt \xcd"(" ArgumentList\opt \xcd")" ClassBody\opt \\
                     \| AmbiguousName \xcd"." \xcd"new" Id TypeArgs\opt \xcd"(" ArgumentList\opt \xcd")" ClassBody\opt \\
\end{bbgrammar}
%##)

This constructs a new object, and calls some code, called a {\em constructor},
to initialize the newly-created object properly.

Constructors are defined like methods, except that they must be named \xcd`this`
and ordinary methods may not be.    The content of a constructor body has
certain capabilities (\eg, \xcd`val` fields of the object may be initialized)
and certain restrictions (\eg, most methods cannot be called); see
\Sref{ObjectInitialization} for the details.

\begin{ex}

The following class provides two constructors.  The unary constructor 
\xcd`def this(b : Int)` allows initialization of the \xcd`a` field to an 
arbitrary value.  The nullary constructor \xcd`def this()` gives it a default
value of 10.  The \xcd`example` method illustrates both of these calls.


%~~gen ^^^ ClassesCtor10
% package ClassesCtor10;
%~~vis
\begin{xten}
class C {
  public val a : Int;
  def this(b : Int) { a = b; } 
  def this()        { a = 10; }
  static def example() {
     val two = new C(2);
     assert two.a == 2;
     val ten = new C(); 
     assert ten.a == 10;
  }
}
\end{xten}
%~~siv
% class Hook{ def run() {C.example(); return true;}}
%~~neg
\end{ex}

\subsection{Automatic Generation of Constructors}
\index{constructor!generated}

Classes that have no constructors written in the class declaration are
automatically given a constructor which sets the class properties and does
nothing else. If this automatically-generated constructor is not valid (\eg,
if the class has \xcd`val` fields that need to be initialized in a
constructor), the class has no constructor, which is a static error.

\begin{ex}
The following class has no explicit constructor.
Its implicit constructor is 
\xcd`def this(x:Int){property(x);}`
This implicit constructor is valid, and so is the class. 
%~~gen ^^^ ClassesCtor20
% package ClassesCtor20;
%~~vis
\begin{xten}
class C(x:Int) {
  static def example() {
    val c : C = new C(4);
    assert c.x == 4;
  }
}
\end{xten}
%~~siv
% class Hook{ def run() {C.example(); return true;}}
%~~neg
\noindent 


The following class has the same default constructor.  However, that
constructor does not initialize \xcd`d`, and thus is invalid.  This 
class does not compile; it needs an explicit constructor.
%~~gen ^^^ ClassCtor30_MustFailCompile
% NOCOMPILE
%~~vis
\begin{xten}
// THIS CODE DOES NOT COMPILE
class Cfail(x:Int) {
  val d: Int;
  static def example() {
    val wrong = new Cfail(40);
  }
}
\end{xten}
%~~siv
%
%~~neg


\end{ex}

\subsection{Calling Other Constructors}
\label{sect:call-another-ctor}

The {\em first} statement of a constructor body may be a call of the form 
\xcd`this(a,b,c)` or \xcd`super(a,b,c)`.  The former will execute the body of
the matching constructor of the current class; the latter, of the superclass. 
This allows a measure of abstraction in constructor definitions; one may be
defined in terms of another.

\begin{ex}
The following class has two constructors.  \xcd`new Ctors(123)` constructs a
new \xcd`Ctors` object with parameter 123.  \xcd`new Ctors()` constructs one
whose parameter has a default value of 100: 
%~~gen ^^^ Classes5q6q
% package Classes5q6q;
%~~vis
\begin{xten}
class Ctors {
  public val a : Int;
  def this(a:Int) { this.a = a; }
  def this()      { this(100);  }
}
\end{xten}
%~~siv
%class Hook{ def run() {
% val x = new Ctors(10); assert x.a == 10;
% val y = new Ctors(); assert y.a == 100;
% return true;}}
%~~neg
\end{ex}

In the case of a class which implements \xcd`operator ()` 
--- or any other constructor and application with the same signature --- 
this can be ambiguous.  If \xcd`this()` appears as the first statement of a
constructor body, it could, in principle, mean either a constructor call or an
operator evaluation.   This ambiguity is resolved so that \xcd`this()` always
means the constructor invocation.  If, for some reason, it is necessary to
invoke an application operator as the first meaningful statement of a
constructor, precede it with a dummy statement, such as \xcd`if(false);`  

\section{Static initialization}
\label{StaticInitialization}
\index{initialization!static}
The \Xten{} runtime implements the following procedure to ensure
reliable initialization of the static state of classes.


Execution (of an entire X10 program) commences with a single thread executing
the 
\emph{initialization} phase of an \Xten{} computation at place \Xcd{0}. This
phase must complete successfully before the body of the \Xcd{main} method is
executed.

The initialization phase should be thought of as if it is implemented in
the following fashion. (The implementation may do something more
efficient as long as it is faithful to this semantics.)

\begin{xten}
Within the scope of a new finish
for every static field f of every class C 
   (with type T and initializer e):
async {
  val l = e; 
  ateach (Dist.makeUnique()) {
     assign l to the static f field of 
         the local C class object;
     mark the f field of the local C 
         class object as initialized;
  }
}
\end{xten}

During this phase, any read of a static field \Xcd{C.f} (where \Xcd{f} is of type \Xcd{T})
is replaced by a call to the method \Xcd{C.read\_f():T} defined on class \Xcd{C}
as follows

\begin{xten}
def read_f():T {
   when (initialized(C.f)){};
   return C.f;
}
\end{xten}
 

If all these activities terminate normally, all static fields have values of
their declared types, 
and the \Xcd{finish} terminates normally. If
any activity throws an exception, the \Xcd{finish} throws an
exception. Since no user code is executing which can catch exceptions
thrown by the finish, such exceptions are printed on the console, and
computation aborts.

If the activities deadlock, the implementation deadlocks.

In all cases, the main method is executed only once all static fields
have been initialized correctly.

Since static state is immutable and is replicated to all places via 
the initialization phase as described above, it can be accessed from
any place.



\section{User-Defined Operators}
\label{sect:operators}
\index{operator}
\index{operator!user-defined}

%##(MethodDecl
\begin{bbgrammar}
%(FROM #(prod:MethodDecl)#)
          MethodDecl \: MethMods \xcd"def" Id TypeParams\opt Formals Guard\opt HasResultType\opt Offers\opt MethodBody & (\ref{prod:MethodDecl}) \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" BinOp \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt PrefixOp \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"this" BinOp \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" BinOp \xcd"this" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt PrefixOp \xcd"this" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" \xcd"this" TypeParams\opt Formals Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" \xcd"this" TypeParams\opt Formals \xcd"=" \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" \xcd"as" Type Guard\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" \xcd"as" \xcd"?" Guard\opt HasResultType\opt Offers\opt MethodBody \\
                     \| MethMods \xcd"operator" TypeParams\opt \xcd"(" Formal  \xcd")" Guard\opt HasResultType\opt Offers\opt MethodBody \\
\end{bbgrammar}
%##)


It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a \xcd`Poly` class of
polynomials -- for the sake of illustration, single-variable polynomials with
\xcd`Int` coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: \xcd`+` to add, \xcd`*` to multiply,
\xcd`-` to subtract, and \xcd`p(x)` to compute the value of the polynomial at
argument \xcd`x`.  We would like to write code thus: 
%~~gen ^^^ Classes160
% package Classes.In.Poly101;
% // Integer-coefficient polynomials of one variable.
% class Poly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public def a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%
%   public static operator (c : Int) as Poly = new Poly([c as Int]);
%
%   public operator this(x:Int) {
%     val d = this.degree();
%     var s : Int = this.a(d);
%     for( i in 1 .. this.degree() ) {
%        s = x * s + a(d-i);
%     }
%     return s;
%   }
%
%   public operator this + (p:Poly) =  new Poly(
%      new Array[Int](
%         Math.max(this.coeff.size, p.coeff.size),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%   public operator this - (p:Poly) = this + (-1)*p;
%
%   public operator this * (p:Poly) = new Poly(
%      new Array[Int](
%        this.degree() + p.degree() + 1,
%        (k:Int) => sumDeg(k, this, p)
%        )
%      );
%
%
%   public operator (n : Int) + this = (n as Poly) + this;
%   public operator this + (n : Int) = (n as Poly) + this;
%
%   public operator (n : Int) - this = (n as Poly) + (-1) * this;
%   public operator this - (n : Int) = ((-n) as Poly) + this;
%
%   public operator (n : Int) * this = new Poly(
%      new Array[Int](
%        this.degree()+1,
%        (k:Int) => n * this.a(k)
%      ));
%   private static def sumDeg(k:Int, a:Poly, b:Poly) {
%      var s : Int = 0;
%      for( i in 0 .. k ) s += a.a(i) * b.a(k-i);
%        // x10.io.Console.OUT.println("sumdeg(" + k + "," + a + "," + b + ")=" + s);
%      return s;
%      };
%   public final def toString() = {
%      var allZeroSoFar : Boolean = true;
%      var s : String ="";
%      for( i in 0..this.degree() ) {
%        val ai = this.a(i);
%        if (ai == 0) continue;
%        if (allZeroSoFar) {
%           allZeroSoFar = false;
%           s = term(ai, i);
%        }
%        else
%           s +=
%              (ai > 0 ? " + " : " - ")
%             +term(ai, i);
%      }
%      if (allZeroSoFar) s = "0";
%      return s;
%   }
%   private final def term(ai: Int, n:Int) = {
%      val xpow = (n==0) ? "" : (n==1) ? "x" : "x^" + n ;
%      return (ai == 1) ? xpow : "" + Math.abs(ai) + xpow;
%   }
%
%   public static def Main(ss:Array[String](1)):void {main(ss);};
%


%~~vis
\begin{xten}
  public static def main(Array[String](1)):void {
     val X = new Poly([0,1]);
     val t <: Poly = 7 * X + 6 * X * X * X; 
     val u <: Poly = 3 + 5*X - 7*X*X;
     val v <: Poly = t * u - 1;
     for( i in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

\end{xten}
%~~siv
%}
%~~neg

Writing the same code with method calls, while possible, is far less elegant: 
%~~gen ^^^ Classes170

%package Classes.In.Remedial.Poly101;
% // Integer-coefficient polynomials of one variable.
% class UglyPoly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public  def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%
%   public static operator (c : Int) as UglyPoly = new UglyPoly([c as Int]);
%
%   public def apply(x:Int) {
%     val d = this.degree();
%     var s : Int = this.a(d);
%     for( i in 1 .. this.degree() ) {
%        s = x * s + a(d-i);
%     }
%     return s;
%   }
%
%   public operator this + (p:UglyPoly) =  new UglyPoly(
%      new Array[Int](
%         Math.max(this.coeff.size, p.coeff.size),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%   public operator this - (p:UglyPoly) = this + (-1)*p;
%
%   public operator this * (p:UglyPoly) = new UglyPoly(
%      new Array[Int](
%        this.degree() + p.degree() + 1,
%        (k:Int) => sumDeg(k, this, p)
%        )
%      );
%
%
%   public operator (n : Int) + this = (n as UglyPoly) + this;
%   public operator this + (n : Int) = (n as UglyPoly) + this;
%
%   public operator (n : Int) - this = (n as UglyPoly) + (-1) * this;
%   public operator this - (n : Int) = ((-n) as UglyPoly) + this;
%
%   public operator (n : Int) * this = new UglyPoly(
%      new Array[Int](
%        this.degree()+1,
%        (k:Int) => n * this.a(k)
%      ));
%   private static def sumDeg(k:Int, a:UglyPoly, b:UglyPoly) {
%      var s : Int = 0;
%      for( i in 0 .. k ) s += a.a(i) * b.a(k-i);
%        // x10.io.Console.OUT.println("sumdeg(" + k + "," + a + "," + b + ")=" + s);
%      return s;
%      };
%   public final def toString() = {
%      var allZeroSoFar : Boolean = true;
%      var s : String ="";
%      for( i in 0..this.degree() ) {
%        val ai = this.a(i);
%        if (ai == 0) continue;
%        if (allZeroSoFar) {
%           allZeroSoFar = false;
%           s = term(ai, i);
%        }
%        else
%           s +=
%              (ai > 0 ? " + " : " - ")
%             +term(ai, i);
%      }
%      if (allZeroSoFar) s = "0";
%      return s;
%   }
%   private final def term(ai: Int, n:Int) = {
%      val xpow = (n==0) ? "" : (n==1) ? "x" : "x^" + n ;
%      return (ai == 1) ? xpow : "" + Math.abs(ai) + xpow;
%   }
%
%   def mult(p:UglyPoly) : UglyPoly = this * p;
%   def mult(n:Int)      : UglyPoly = n * this;
%   def plus(p:UglyPoly) : UglyPoly = this + p;
%   def plus(n:Int)      : UglyPoly = n + this;
%   def minus(p:UglyPoly): UglyPoly = this - p;
%   def minus(n:Int)     : UglyPoly = this - n;
%   static def const(n:Int): UglyPoly = n as UglyPoly;
%
%~~vis
\begin{xten}
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t <: UglyPoly 
           = X.mult(7).plus(
               X.mult(X).mult(X).mult(6));  
     val u <: UglyPoly 
           = const(3).plus(
               X.mult(5)).minus(X.mult(X).mult(7));
     val v <: UglyPoly = t.mult(u).minus(1);
     for( i in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
\end{xten}
%~~siv
%}
%~~neg

The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as \xcd`1+X`.



Most X10 operators can be given definitions.\footnote{Indeed, even for the
standard types, these operators are defined in the library.  Not even as basic
an operation as integer addition is built into the language.  Conversely, if
you define a full-featured numeric type, it will have most of the privileges that
the standard ones enjoy.  The missing priveleges are (1) literals; (2) 
the \xcd`..` operator won't compute the \xcd`zeroBased` and \xcd`rail`
properties as it does for \xcd`Int` ranges; (3) \xcd`*` won't track ranks, as
it does for \xcd`Region`s; 
(4) \xcd`&&` and \xcd`||` won't short-circuit, as they do for \xcd`Boolean`s, 
(5) \xcd`a==b` will only coincide with
\xcd`a.equals(b)` if coded that way; and (6) it is impossible to define an
operation like \xcd`String.+` which converts both its left and right arguments
from any type.  For example, a \xcd`Polar` type might
have many representations for the origin, as radius 0 and any angle; these
will be \xcd`equals()`, but will not be \xcd`==`.}  (However, \xcd`&&` and
\xcd`||` 
are only short-circuiting for \xcd`Boolean` expressions; user-defined versions
of these operators have no special execution behavior.)

The user-definable operations are (in order of precedence): \\
\begin{tabular}{l}
implicit type coercions\\
postfix \xcd`()`\\
\xcd`as T`\\
these unary operators:  \xcd`- + ! ~ | & / ^ * %`\\
\xcd`..`\\
\xcd`*      /       %      **`\\
\xcd`+` \xcd`     -` \\
\xcd`<<     >>      >>>    ->     <-     >-      -<      !`\\
\xcd`>      ` \xcd`>=     ` \xcd`<     ` \xcd`<=     ` 
\xcd`~      !~`\\
\xcd`&` \\
\xcd`^` \\
\xcd`|` \\
\xcd`&&` \\
\xcd`||` \\
\end{tabular}

Several of these operators have no standard meaning on any library type, and
are included purely for programmer convenience.  


Many operators may be defined either in \xcd`static` or instance forms.  Those
defined in instance form are dynamically dispatched, just like an instance
method.  Those defined in static form are statically dispatched, just like a
static method.  Operators are scoped like methods; static operators are scoped
like static methods.

\begin{ex}
%~~gen ^^^ Classes6a1j
% package oifClasses6a1j;
% class Whatever {
% 
%~~vis
\begin{xten}
static class Trace(n:Int){
  public static operator !(f:Trace) 
      = new Trace(10 * f.n + 1);
  public operator -this = new Trace (10 * this.n + 2);
}
static class Brace extends Trace{
  def this(n:Int) { super(n); }
  public operator -this = new Brace (10 * this.n + 3);
  static def example() {
     val t = new Trace(1);
     assert (!t).n == 11;
     assert (-t).n == 12 && (-t instanceof Trace);
     val b = new Brace(1);
     assert (!b).n == 11;
     assert (-b).n == 13 && (-b instanceof Brace);
  }
}

\end{xten}
%~~siv
% // And checking the unambiguous syntax while I'm here...
% //static class Glook { def checky(t:Trace) { 
% //   Trace.operator !(t);
% //   t.operator -();
% //} }
% }
%~~neg
\end{ex}

%%OP%% Operators may be invoked by unambiguous syntax, loosely akin to a
%%OP%% fully-qualified name. For example, \xcd`!t` above may be invoked as
%%OP%% \xcd`Trace.operator !(t)`. This unambiguous syntax may be used even if there
%%OP%% are several \xcd`!` operators that could apply to \xcd`t`, rendering the
%%OP%% convenient short form \xcd`!t` unavailable in some context.




\subsection{Binary Operators}

Binary operators, illustrated by \xcd`+`, may be defined statically in a
container \xcd`A` as:
\begin{xten}
static operator (b:B) + (c:C) = ...;
\end{xten}
%%OP%% In this case it may be invoked as \xcd`A.operator +(b,c)`.
Or, it may be defined as  as an instance operator by one of the forms:
\begin{xten}
operator this + (b:B) = ...;
operator (b:B) + this = ...;
\end{xten}
%%OP%% and be invoked as 
%%OP%% \xcd`a.operator +(b)`
%%OP%% and as 
%%OP%% \xcd`a.operator ()+(b)` 
%%OP%% respectively.

\begin{ex}

Defining the sum \xcd`P+Q` of two polynomials looks much like a method
definition.  It uses the \xcd`operator` keyword instead of \xcd`def`, and
\xcd`this` appears in the definition in the place that a \xcd`Poly` would
appear in a use of the operator.  So, 
\xcd`operator this + (p:Poly)` explains how to add \xcd`this` to a
\xcd`Poly` value.
%~~gen ^^^ Classes180
% package Classes.In.Poly102;
%~~vis
\begin{xten}
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { 
    this.coeff = coeff;}
  public def degree() = coeff.size-1;
  public def  a(i:Int) 
    = (i<0 || i>this.degree()) ? 0 : coeff(i);
  public operator this + (p:Poly) =  new Poly(
     new Array[Int](
        Math.max(this.coeff.size, p.coeff.size),
        (i:Int) => this.a(i) + p.a(i)
     )); 
  // ... 
\end{xten}
%~~siv
%   public operator (n : Int) + this = new Poly([n as Int]) + this;
%   public operator this + (n : Int) = new Poly([n as Int]) + this;
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg


The sum of a polynomial and an integer, \xcd`P+3`, looks like
an overloaded method definition.  
%~~gen ^^^ Classes190
% package Classes.In.Poly103;
% class Poly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
% 
%   public operator this + (p:Poly) =  new Poly(
%      new Array[Int](
%         Math.max(this.coeff.size, p.coeff.size),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%    public operator (n : Int) + this = new Poly([n as Int]) + this;
%~~vis
\begin{xten}
   public operator this + (n : Int) 
          = new Poly([n as Int]) + this;
\end{xten}
%~~siv
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg


However, we want to allow the sum of an integer and a polynomial as well:
\xcd`3+P`.  It would be quite inconvenient to have to define this as a method
on \xcd`Int`; changing \xcd`Int` is far outside of normal coding.  So, we
allow it as a method on \xcd`Poly` as well.


%~~gen ^^^ Classes200
% package Classes.In.Poly104o;
% class Poly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
% 
%   public operator this + (p:Poly) =  new Poly(
%      new Array[Int](
%         Math.max(this.coeff.size, p.coeff.size),
%         (i:Int) => this.a(i) + p.a(i)
%      ));
%~~vis
\begin{xten}
   public operator (n : Int) + this 
          = new Poly([n as Int]) + this;
\end{xten}
%~~siv
% 
%   public operator this + (n : Int) = new Poly([n as Int]) + this;
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg

Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
\xcd`Poly`s could have been written:
%~~gen ^^^ Classes210
% package Classes.In.Poly105;
% class Poly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%~~vis
\begin{xten}
  public static operator (p:Poly) + (q:Poly) =  new Poly(
     new Array[Int](
        Math.max(q.coeff.size, p.coeff.size),
        (i:Int) => q.a(i) + p.a(i)
     ));
\end{xten}
%~~siv
%
%   public operator (n : Int) + this = new Poly([n as Int]) + this;
%   public operator this + (n : Int) = new Poly([n as Int]) + this;
% 
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = x+x+x;
%      val q <: Poly = 1+x;
%      val r <: Poly = x+1;
%   }
%     
% }
%~~neg

\end{ex}

When X10 attempts to typecheck a binary operator expression like \xcd`P+Q`, it
first typechecks \xcd`P` and \xcd`Q`. Then, it looks for operator declarations
for \xcd`+` in the types of \xcd`P` and \xcd`Q`. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a {\em best-matching} operation, \viz{} one which does
not require the operands to be converted to another type. For example,
\xcd`operator this + (n:Long)` and \xcd`operator this + (n:Int)` both apply to
\xcd`p+1`, because \xcd`1` can be converted from an \xcd`Int` to a \xcd`Long`.
However, the \xcd`Int` version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.


\subsection{Unary Operators}

Unary operators,  illustrated by \xcd`!`, may be defined statically in
container 
\xcd`A` as 
\begin{xten}
static operator !(x:A) = ...;
\end{xten}
or as instance operators by: 
\begin{xten}
operator !this = ...;
\end{xten}

%%OP%% A statically-defined unary operator \xcd`!` may be invoked on \xcd`a:A` as 
%%OP%% \xcd`A.operator !(a)`.  An instance operator may be invoked as
%%OP%% \xcd`a.operator !()`.  

The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

\begin{ex}
The operator to negate a polynomial is: 

%~~gen ^^^ Classes220
% package Classes.In.Poly106;
% class Poly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%~~vis
\begin{xten}
  public operator - this = new Poly(
    new Array[Int](coeff.size, (i:Int) => -coeff(i))
    );
\end{xten}
%~~siv
%   def makeSureItWorks() {
%      val x = new Poly([0,1]);
%      val p <: Poly = -x;
%   }
% }
%~~neg



\end{ex}


\subsection{Type Conversions}
\label{sect:type-conv}
\index{type conversion!user-defined}


Explicit type conversions, \xcd`e as A`, can be defined as operators on
class \xcd`A`, or on the container type of \xcd`e`.  These must be static
operators, 

To define an operator in \xcd`class A` (or \xcd`struct A)` converting values
of ttype \xcd`B` into type \xcd`A`, use the syntax: 
\begin{xten}
static operator (x:B) as ? {c} = ... 
\end{xten}
The \xcd`?` indicates the containing type \xcd`A`.  
The guard clause \xcd`{c}` may be omitted.




\begin{ex}
%~~gen ^^^ Classes230
% package Classes_explicit_type_conversions_a;
%~~vis
\begin{xten}
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public static operator (a:Int) as ? = new Poly([a as Int]);
  public static def main(Array[String](1)):void {
     val three : Poly = 3 as Poly;
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}


The \xcd`?` may be given a bound, such as \xcd`as ? <: Caster`, if desired.
  
Explicit type conversions {\em out} of container \xcd`B` to some other
container \xcd`A` may be defined in \xcd`B`, as well.  The syntax for this
does not involve \xcd`?`.  

\begin{ex}
%~~gen ^^^ Classes3g2h
% package Classes3g2h;
% KNOWNFAIL
%~~vis
\begin{xten}
class Numbered(n:Int) {
  public static operator (x:Numbered) as Int = x.n;
  public static def example(){
     val n3 = new Numbered(3);
     assert n3 as Int == 3;
  }
}
\end{xten}
%~~siv
% class Hook{ def run() {Numbered.example(); return true;}}
%~~neg

\end{ex}


There is little difference between an explicit conversion \xcd`e as T` and a
method call \xcd`e.asT()`.  The explicit conversion does say undeniably what
the result type will be.  However, as described in \Sref{sect:ambig-cast},
sometimes the built-in meaning of \xcd`as` as a cast overrides the
user-defined explicit conversion.  

Explicit casts are most suitable for cases
which resemble the use of explicit casts among the arithmetic types, where, 
for example, \xcd`1.0 as Int` is a way to turn a floating-point number into the
corresponding integer.  
While there is nothing in X10 which
requires it, \xcd`e as T` has the connotation that it gives a good
approximation of \xcd`e` in type \xcd`T`, just as \xcd`1` is a good
(indeed, perfect) approximation of \xcd`1.0` in type \xcd`Int`.  

\subsection{Implicit Type Coercions}
\label{sect:ImplicitCoercion}
\index{type conversion!implicit}

An implicit type conversion from \xcd`U`  to \xcd`T` may be specified in
either \xcd`U` or \xcd`T`.  
The syntax for it, in either case, is: 
\begin{xten}
static operator (u:U) : T = e;
\end{xten}
%%OP%% which may be invoked by the unambiguous syntax 
%%OP%% \xcd`T.operator[T](u)` or \xcd`U.operator[T](u)`.
%%OP%% 




Implicit coercions are used automatically by the compiler on method calls 
(\Sref{sect:MethodResolution}) and assignments (\Sref{domedomedome}).


\begin{ex}
We can define an implicit coercion from \xcd`Int` to \xcd`Poly`,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define \xcd`+` on
two polynomials.  The
calculation \xcd`1+x` coerces \xcd`1` to a polynomial and uses polynomial
addition to add it to \xcd`x`.

%~~gen ^^^ Classes240
% package Classes.And.Implicit.Coercions;
% class Poly {
%   public val coeff : Array[Int](1);
%   public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
%   public def degree() = coeff.size-1;
%   public def  a(i:Int) = (i<0 || i>this.degree()) ? 0 : coeff(i);
%   public final def toString() = {
%      var allZeroSoFar : Boolean = true;
%      var s : String ="";
%      for( i in 0..this.degree() ) {
%        val ai = this.a(i);
%        if (ai == 0) continue;
%        if (allZeroSoFar) {
%           allZeroSoFar = false;
%           s = term(ai, i);
%        }
%        else 
%           s += 
%              (ai > 0 ? " + " : " - ")
%             +term(ai, i);
%      }
%      if (allZeroSoFar) s = "0";
%      return s;
%   }
%   private final def term(ai: Int, n:Int) = {
%      val xpow = (n==0) ? "" : (n==1) ? "x" : "x^" + n ;
%      return (ai == 1) ? xpow : "" + Math.abs(ai) + xpow;
%   }

%~~vis
\begin{xten}
  public static operator (c : Int) : Poly 
     = new Poly([c as Int]);

  public static operator (p:Poly) + (q:Poly) = new Poly(
      new Array[Int](
        Math.max(p.coeff.size, q.coeff.size),
        (i:Int) => p.a(i) + q.a(i)
     ));

  public static def main(Array[String](1)):void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
\end{xten}
%~~siv
%}
%~~neg
\end{ex}



\subsection{Assignment and Application Operators}
\index{assignment operator}
\index{application operator}
\index{()}
\index{()=}
\label{set-and-apply}
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The \xcd`Array`-like classes take advantage
of both of these in \xcd`a(i) = a(i) + 1`.  

\xcd`a(b,c,d)`
is an operator call, to an operator defined with 
\xcd`public operator this(b:B, c:C, d:D)`.  It may be overloaded.
For
example, an ordered dictionary structure could allow subscripting by numbers
with \xcd`public operator this(i:Int)`, and by strings with 
\xcd`public operator this(s:String)`.  


\xcd`a(i,j)=b` is an \xcd`operator` as well, with zero or more indices
\xcd`i,j`.  It may also be overloaded. 

The update operations \xcd`a(i) += b` 
(for all binary operators in place of \xcd`+`)
are defined to be the same as the
corresponding \xcd`a(i) = a(i) + b`. This applies for all arities of
arguments, and all types, and all binary operations. Of course to use this,
the \xcd`+`, application and assignment \xcd`operator`s must be defined.


\begin{ex}

The \xcd`Oddvec` class of somewhat peculiar vectors illustrates this.

\xcd`a()` returns a string representation of the oddvec, which ordinarily
would 
be done by \xcd`toString()` instead.  
\xcd`a(i)` sensibly picks out one of the three
coordinates of \xcd`a`.
\xcd`a()=b` sets all the coordinates of \xcd`a` to \xcd`b`.
\xcd`a(i)=b` assigns to one of the
coordinates.  \xcd`a(i,j)=b` assigns different values to \xcd`a(i)` and
\xcd`a(j)`.  

%~~gen ^^^ Classes250
% package Classes.Assignments1_oddvec;
%~~vis
\begin{xten}
class Oddvec {
  var v : Array[Int](1) = new Array[Int](3, (Int)=>0);
  public operator this () = 
      "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public operator this () = (newval: Int) { 
    for(p in v) v(p) = newval;
  }
  public operator this(i:Int) = v(i);
  public operator this(i:Int, j:Int) = [v(i),v(j)];
  public operator this(i:Int) = (newval:Int) 
      = {v(i) = newval;}
  public operator this(i:Int, j:Int) = (newval:Int) 
      = { v(i) = newval; v(j) = newval+1;} 
  public def example() {
    this(1) = 6;   assert this(1) == 6;
    this(1) += 7;  assert this(1) == 13;
  }
\end{xten}
%~~siv
% }
%  class Hook { def run() {
%     val a = new Oddvec();
%     assert a().equals("(0,0,0)");
%     a() = 1;
%     assert a().equals("(1,1,1)");
%     a(1) = 4;
%     assert a().equals("(1,4,1)");
%     a(0,2) = 5;
%     assert a().equals("(5,4,6)");
%     return true;
%   }
% }
%~~neg

\end{ex}

\section{Class Guards and Invariants}\label{DepType:ClassGuard}
\index{type invariants}
\index{class invariants}
\index{invariant!type}
\index{invariant!class}
\index{guard}


Classes (and structs and interfaces) may specify a {\em class guard}, a
constraint which must hold on all values of the class.    In the following
example, a \xcd`Line` is defined by two distinct \xcd`Pt`s\footnote{We use \xcd`Pt`
to avoid any possible confusion with the built-in class \xcd`Point`.}
%~~gen ^^^ Classes260
% package classes.guards.invariants.glurp;
%~~vis
\begin{xten}
class Pt(x:Int, y:Int){}
class Line(a:Pt, b:Pt){a != b} {}
\end{xten}
%~~siv
%
%~~neg

In most cases the class guard could be phrased as a type constraint on a property of
the class instead, if preferred.  Arguably, a symmetric constraint like two
points being different is better expressed as a class guard, rather than
asymmetrically as a constraint on one type: 
%~~gen ^^^ Classes270
% package classes.guards.invariants.glurp2;
% class Pt(x:Int, y:Int){}
%~~vis
\begin{xten}
class Line(a:Pt, b:Pt{a != b}) {}
\end{xten}
%~~siv
%
%~~neg



\label{DepType:TypeInvariant}
\index{class invariant}
\index{invariant!class}
\index{class!invariant}
\label{DepType:ClassGuardDef}



With every container  or interface \xcd"T" we associate a {\em type
invariant} $\mathit{inv}($\xcd"T"$)$, which describes the guarantees on the
properties of values of type \xcd`T`.  

Every value of \xcd`T` satisfies $\mathit{inv}($\xcd"T"$)$ at all times.  This
is somewhat stronger than the concept of type invariant in most languages
(which only requires that the invariant holds when no method calls are
active).  X10 invariants only concern properties, which are immutable; thus,
once established, they cannot be falsified.

The type
invariant associated with \xcd"x10.lang.Any"
is 
\xcd"true".

The type invariant associated with any interface or struct \xcd"I" that extends
interfaces \xcdmath"I$_1$, $\dots$, I$_k$" and defines properties
\xcdmath"x$_1$: P$_1$, $\dots$, x$_n$: P$_n$" and
specifies a guard \xcd"c" is given by:

\begin{xtenmath}
$\mathit{inv}$(I$_1$) && $\dots$ && $\mathit{inv}$(I$_k$) &&
self.x$_1$ instanceof P$_1$ &&  $\dots$ &&  self.x$_n$ instanceof P$_n$ 
&& c  
\end{xtenmath}

Similarly the type invariant associated with any class \xcd"C" that
implements interfaces \xcdmath"I$_1$, $\dots$, I$_k$",
extends class \xcd"D" and defines properties
\xcdmath"x$_1$: P$_1$, $\dots$, x$_n$: P$_n$" and
specifies a guard \xcd"c" is
given by the same thing with the invariant of the superclass \xcd`D` conjoined:
\begin{xtenmath}
$\mathit{inv}$(I$_1$) && $\dots$ && $\mathit{inv}$(I$_k$) 
&& self.x$_1$ instanceof P$_1$ &&  $\dots$ &&  self.x$_n$ instanceof P$_n$ 
&& c  
&& $\mathit{inv}$(D)
\end{xtenmath}


Note that the type invariant associated with a class entails the type
invariants of each interface that it implements (directly or indirectly), and
the type invariant of each ancestor class.
It is guaranteed that for any variable \xcd"v" of
type \xcd"T{c}" (where \xcd"T" is an interface name or a class name) the only
objects \xcd"o" that may be stored in \xcd"v" are such that \xcd"o" satisfies
$\mathit{inv}(\mbox{\xcd"T"}[\mbox{\xcd"o"}/\mbox{\xcd"this"}])
\wedge \mbox{\xcd"c"}[\mbox{\xcd"o"}/\mbox{\xcd"self"}]$.



\subsection{Invariants for {\tt implements} and {\tt extends} clauses}\label{DepType:Implements}
\label{DepType:Extends}
\index{type-checking!implements clause}
\index{type-checking!extends clause}
\index{implements}
\index{extends}
Consider a class definition
\begin{xtenmath}
$\mbox{\emph{ClassModifiers}}^{\mbox{?}}$
class C(x$_1$: P$_1$, $\dots$, x$_n$: P$_n$) extends D{d}
   implements I$_1${c$_1$}, $\dots$, I$_k${c$_k$}
$\mbox{\emph{ClassBody}}$
\end{xtenmath}

These two rules must be satisfied:


\begin{itemize}

\item 
The type invariant \xcdmath"$\mathit{inv}$(C)" of \xcd"C" must entail
\xcdmath"c$_i$[this/self]" for each $i$ in $\{1, \dots, k\}$


\item The return type \xcd"c" of each constructor in a class \xcd`C`
must entail the invariant \xcdmath"$\mathit{inv}$(C)".
\end{itemize}

\subsection{Invariants and constructor definitions}
\index{invariant!and constructor}
\index{constructor!and invariant}

A constructor for a class \xcd"C" is guaranteed to return an object of the
class on successful termination. This object must satisfy  \xcdmath"$\mathit{inv}$(C)", the
class invariant associated with \xcd"C" (\Sref{DepType:TypeInvariant}).
However,
often the objects returned by a constructor may satisfy {\em stronger}
properties than the class invariant. \Xten{}'s dependent type system
permits these extra properties to be asserted with the constructor in
the form of a constrained type (the ``return type'' of the constructor):

%##(CtorDecl
\begin{bbgrammar}
%(FROM #(prod:CtorDecl)#)
            CtorDecl \: Mods\opt \xcd"def" \xcd"this" TypeParams\opt Formals Guard\opt HasResultType\opt Offers\opt CtorBody & (\ref{prod:CtorDecl}) \\
\end{bbgrammar}
%##)

\label{ConstructorGuard}

The parameter list for the constructor
may specify a \emph{guard} that is to be satisfied by the parameters
to the list.

\begin{ex}
%%TODO--rewrite this
Here is another example, constructed as a simplified 
version of \Xcd{x10.array.Region}.  The \xcd`mockUnion` method 
has the type, though not the value, that a true \xcd`union` method would have.

%~~gen ^^^ Classes280
%package Classes.SimplifiedRegion;
%~~vis
\begin{xten}
class MyRegion(rank:Int) {
  static type MyRegion(n:Int)=MyRegion{rank==n};
  def this(r:Int):MyRegion(r) {
    property(r);
  }
  def this(diag:Array[Int](1)):MyRegion(diag.size){ 
    property(diag.size);
  }
  def mockUnion(r:MyRegion(rank)):MyRegion(rank) = this;
  def example() {
    val R1 : MyRegion(3) = new MyRegion([4,4,4 as Int]); 
    val R2 : MyRegion(3) = new MyRegion([5,4,1]); 
    val R3 = R1.mockUnion(R2); // inferred type MyRegion(3)
  }
}
\end{xten}
%~~siv
%
%~~neg
The first constructor returns the empty region of rank \Xcd{r}.  The
second constructor takes a \Xcd{Array[Int](1)} of arbitrary length
\Xcd{n} and returns a \Xcd{MyRegion(n)} (intended to represent the set
of points in the rectangular parallelopiped between the origin and the
\Xcd{diag}.)

The code in \xcd`example` typechecks, and \xcd`R3`'s type is inferred as
\xcd`MyRegion(3)`.  


\end{ex}

   Let \xcd"C" be a class with properties
   \xcdmath"p$_1$: P$_1$, $\dots$, p$_n$: P$_n$", and invariant \xcd"c"
   extending the constrained type \xcd"D{d}" (where \xcd"D" is the name of a
   class).



   For every constructor in \xcd"C" the compiler checks that the call to
   super invokes a constructor for \xcd"D" whose return type is strong enough
   to entail \xcd"d". Specifically, if the call to super is of the form 
     \xcdmath"super(e$_1$, $\dots$, e$_k$)"
   and the static type of each expression \xcdmath"e$_i$" is
   \xcdmath"S$_i$", and the invocation
   is statically resolved to a constructor
\xcdmath"def this(x$_1$: T$_1$, $\dots$, x$_k$: T$_k$){c}: D{d$_1$}"
   then it must be the case that 
\begin{xtenmath}
x$_1$: S$_1$, $\dots$, x$_i$: S$_i$ entails x$_i$: T$_i$  (for $i \in \{1, \dots, k\}$)
x$_1$: S$_1$, $\dots$, x$_k$: S$_k$ entails c  
d$_1$[a/self], x$_1$: S$_1$, ..., x$_k$: S$_k$ entails d[a/self]      
\end{xtenmath}
\noindent where \xcd"a" is a constant that does not appear in 
\xcdmath"x$_1$: S$_1$ $\wedge$ ... $\wedge$ x$_k$: S$_k$".

   The compiler checks that every constructor for \xcd"C" ensures that
   the properties \xcdmath"p$_1$,..., p$_n$" are initialized with values which satisfy
   $\mathit{inv}($\xcd"T"$)$, and its own return type \xcd"c'" as follows.  In each constructor, the
   compiler checks that the static types \xcdmath"T$_i$" of the expressions \xcdmath"e$_i$"
   assigned to \xcdmath"p$_i$" are such that the following is
   true:
\begin{xtenmath}
p$_1$: T$_1$, $\dots$, p$_n$: T$_n$ entails $\mathit{inv}($T$)$ $\wedge$ c'     
\end{xtenmath}

(Note that for the assignment of \xcdmath"e$_i$" to \xcdmath"p$_i$"
to be type-correct it must be the
    case that \xcdmath"p$_i$: T$_i$ $\wedge$ p$_i$: P$_i$".) 



The compiler must check that every invocation \xcdmath"C(e$_1$, $\dots$, e$_n$)" to a
constructor is type correct: each argument \xcdmath"e$_i$" must have a static type
that is a subtype of the declared type \xcdmath"T$_i$" for the $i$th
argument of the
constructor, and the conjunction of static types of the argument must
entail the constraint in the parameter list of the constructor.



\input{ObjectInitialization.tex}

\input{MethodResolution.tex}

\input{InnerClasses.tex}
