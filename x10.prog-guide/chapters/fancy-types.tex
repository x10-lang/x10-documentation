\chapter{Fancy Types}

X10's types are a lot more powerful than we've seen so far.  They can do a lot
for you that types in Java and C++ can't do, if you want.   

Now, most of what types do for you is to prevent mistakes.  Here's a mistake: 
\begin{xten}
var total : Int = 0; 
total += "3";
\end{xten}
\xcd`total` is an integer.  You can't add a \xcd`String` value into it. 
This is a bit tricky, because you can add a \xcd`String` {\em to} it: 
\xcd`0 + "3"` evaluates to the string \xcd`"03"`.  In some languages, you {\em
can} add a string into an integer if the string contains a number, so adding
\xcd`"3"` into \xcd`total` would behave just like adding \xcd`3` into
\xcd`total`.  

A good type system will catch this mistake as early as possible, and tell you
about it in as useful a way as possible.  For X10, this means that it'll catch
the mistake when you try to compile your program -- or even sooner, if you're
using the programming environment X10DT -- and it'll print out a message
telling you that the code doesn't fit together right.   

The other thing that well-designed types do is try not to bother you too much.
This is a bit tricky. The ultimate purpose of types {\em is} to bother you --
to get in your face when you're about to goof up. At the very least, you have
to do some work in order to get any value of them. You have to write down some
types in your program, enough to tell X10 what you mean, so it can catch when
you don't do what you meant.  But X10 often lets you leave types off, so
they're not {\em too} much in your face.




\section{Constrained Types}

Here's a perfectly innocuous bit of code that looks just fine: 
%%START X10: ArrayRef.x10 arrayrefRank
\fromfile{ArrayRef.x10}
\begin{xtennum}[]
val a : Array[Int] = [1,2,3];
Console.OUT.println("a(1)=" + a(1));
\end{xtennum}
%%END X10: ArrayRef.x10 arrayrefRank
But when you go to compile it, you get a warning message: 
\begin{verbatim}
Generated a dynamic check for the method call.
\end{verbatim}
(Or, if you are using \xcd`STATIC_CHECKS`, it won't compile at all.)  

What's wrong here is that \xcd`Array[Int]` covers arrays of many different
ranks -- one-dimensional ones like \xcd`[1,2,3]`, two-dimensional,
ten-dimensional, or whatever you like.  When \xcd`a` was declared to have
type \xcd`Array[Int]`, we told X10 to forget what rank \xcd`a`
had.\footnote{This is why you should use \xcd`val a <: Array[Int]...` 
whenever you can -- \xcd`<:` in a \xcd`val` doesn't lose track of this kind of
thing.}

So, when X10 goes to use \xcd`a`, it doesn't know how many subscripts it
takes.   Giving it one subscript, in \xcd`a(1)`, might be right, or it might
be wrong. X10 doesn't know.  So, with dynamic checks on, it sticks in a test
to find out.  

And, since X10 doesn't know, it will do the same thing for \xcd`a(1,2)`.
That will fail at runtime, since \xcd`a` is one-dimensional.  

It would be nice if X10 could handle this sensibly -- if X10 could know that
\xcd`a` was one-dimensional, that one subscript was right, and two were wrong.  

Well, it can do that --- that, and a whole lot more.  The mechanism it uses is
called {\em constrained types}.  Constrained types track things that the
compiler knows about your data, like the ranks of arrays, or that particular
variables aren't \xcd`null`.  


\subsubsection{Tracking Nulls}




One common problem in programs (in most object-oriented languages) is that
some parts of code assume that some objects aren't \xcd`null`, but other parts
of code don't know about this assumption and set them to \xcd`null`.  This can
cause \xcd`NullPointerException`s and considerable premature gray hair.  
For example, 

%%START X10: NeedsNullCheck.x10 needsnullcheck
\fromfile{NeedsNullCheck.x10}
\begin{xtennum}[]
val x : Person = lookUp("Kim Geep");
Console.OUT.println("Kim's phone number is " + x.phoneNumber());
\end{xtennum}
%%END X10: NeedsNullCheck.x10 needsnullcheck

If Kim isn't in the database, \xcd`x.phoneNumber()` will throw an exception.  

If you want to protect yourself against this in X10, you can.  Declare \xcd`x`
with a type that says ``\xcd`x` is a \xcd`Person`, but not \xcd`null`''.  
Using this type obligates you to convince X10 that whatever value you give
\xcd`x` is not null.  Three good ways to convince X10 are: (1) use a
constructor call, since constructors never return \xcd`null`. 
(2) use a method declared to return a non-null value, though you will have to
convince X10 that method is defined properly. (3) Check the value at runtime,
with a type-cast (``\xcd`as`'') operation, 
and make sure it's not \xcd`null` there.\footnote{Method 3, checking values at
runtime, is pretty familiar from defensive programming in Java or C++.  X10's
types, if used this way, have the advantage that you can't {\em forget} to do
the check -- if you forget, your program won't compile.}

For our sample program, we choose a version of database lookup that is
guaranteed never to return \xcd`null`.  If \xcd`lookUpOrCreate(name)` doesn't
find \xcd`name` in the database, it creates a new record for that name.  This
approach doesn't make sense for all applications\footnote{Not even for this
one -- how do we really know the phone number of a newly-created
\xcd`Person`?}.  (In many cases, if some crucial datum really is missing,
there's no way to figure it out, and the best thing that can be done is to
report the error and ask a human for help.  Throwing a
\xcd`NullPointerException` is a greatly inferior choice.)

The code that uses non-null \xcd`Person`s is very much like the code that used
possibly-\xcd`null` ones: 
%%START X10: HasNullCheck.x10 hasnullcheck
\fromfile{HasNullCheck.x10}
\begin{xtennum}[]
val x : Person{self!=null} = lookUpOrCreate("Kim Geep");
Console.OUT.println("Kim's phone number is " + x.phoneNumber());
\end{xtennum}
%%END X10: HasNullCheck.x10 hasnullcheck

The code of \xcd`lookUpOrCreate` keeps track of the fact that its values are
never \xcd`null`.  The database \xcd`db` is a hash-table of
non-\xcd`null`\xcd`Person`s.  \xcd`lookUpOrCreate` itself returns a non-null
\xcd`Person`.  The constructor call at line \xlref{hasnullcheckDB-ctor}{6}
always produces a non-\xcd`null` value, and X10 knows that, so it works out
fine too.
%%START X10: HasNullCheck.x10 hasnullcheckDB
\fromfile{HasNullCheck.x10}
\begin{xtennum}[]
static val db = new HashMap[String, Person{self!=null}]();
static def lookUpOrCreate(name:String) : Person{self!=null} = {
  if( db.containsKey(name)) {
     return db.getOrThrow(name) ;
  }
  val p = new Person(); 
  db.put(name, p);
  return p;
}
\end{xtennum}
%%END X10: HasNullCheck.x10 hasnullcheckDB




\subsection{{\tt self}, {\tt this}, and all that}

Now, it's time to learn what that \xcd`self!=null` means.  You already know
\xcd`!=` and \xcd`null`, but \xcd`self` is new.  

When we're using a type, we can think of it as a test, asking if some thing
under consideration is a member of the type or not.  So, for the type
\xcd`Int`, imagine asking if \xcd`true` is a member (no), or \xcd`18` is
(yes).  With types that come from classes and such, like \xcd`Int`, we don't
need to have a name for the thing under consideration.
When we write a constraint, we do need a name for it -- and that name is
a special X10 keyword, \xcd`self`.  

So, we can write some other constraints.  Like this one, which says that the
variable \xcd`three` is an \xcd`Int` which is equal to \xcd`3`.  
%%START X10: ConstraintExamples.x10 constraintex1
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val three : Int{self==3} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintex1
Of course, if you try to set it to something that {\em isn't} three, it won't
work.  This doesn't compile:
%%START X10: ConstraintExamples.x10 constraintex2
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val four : Int{self==3} = 4; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintex2

Not-equals constraints are sometimes useful for excluding a few problem
values.    For example, if you're defining a reciprocal function, you might
want to constrain the input to avoid dividing by zero:
%%START X10: ConstraintExamples.x10 constraintexrecip
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
static def recip(n:Int{self!=0}) = 1.0/n; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexrecip

This isn't a terrible idea, though it does require you to prove to X10 that
numbers are non-zero when you take their reciprocals.  Here are a few ways
that you can do it: 
%%START X10: ConstraintExamples.x10 constraintexUseRecip
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
static def useRecip(m:Int, n:Int{self!=0}) {
  val a = recip(n); 
  val three : Int{self==3} = 3; 
  val b = recip(three);
  val c = recip(m as Int{self!=0});
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexUseRecip


\begin{description}
\item [Line \xlref{constraintexUseRecip-a}{2}:] Use an argument which has been
      declared to be the right type.  That's an ordinary way to call methods
      anyhow.  Here, the right type is \xcd`Int{self!=0}`.  Since \xcd`n` has
      that type, it's fine.
\item [Line \xlref{constraintexUseRecip-b}{4}:] Use an argument which has a
      {\em more specific} type.  You're used to doing this too, when you have
      a method that takes a \xcd`Person` as an argument and you give it a
      subclass, like \xcd`Dentist`.  

      Here we're doing the same thing, in a
      slightly different way. 
      The type of \xcd`three` is \xcd`Int{self==3}`.  That's a subtype of 
      \xcd`Int{self!=0}`, because every number that {\em is} three {\em isn't}
      zero.    The official word for this is {\em subtyping by strengthening}.  
      \xcd`self==3` is logically {\em stronger} than \xcd`self!=0` --- also
      pronounced ``\xcd`self==3` implies \xcd`self!=0`''.  
      A constrained type with a stronger constraint is always a subtype of a
      type with the same base and a weaker one.  

      (As usual, we didn't have to write the type on line
      \xlref{constraintexUseRecip-decl}{3}.  We  just wrote it to make the
      example clearer.)
      
\item [Line \xlref{constraintexUseRecip-c}{5}:] 
      Use a {\em cast}.  
      At some point, you're going to
      have a value like \xcd`m`, which you don't know in advance is not zero,
      and you're going to have to tell X10 that it's not zero.  The way you
      say ``it's not zero'', here, is to use a type cast  
      \xcd`m as Int{self!=0}`.  This is just the same as any other time you
      have a value of one type and need it to be another type.

      Of course, \xcd`m` might be zero.  If \xcd`m` is zero, this cast fails
      -- \xcd`m as Int{self!=0}` first makes sure that \xcd`m` is an integer
      (which it can do at compile-time), and then that it's not zero (which
      has to be done at runtime).    If \xcd`m` is zero, this throws an
      exception, the same as any other attempt to cast a value to some type it
      isn't.   

      This isn't much of an improvement over getting a division-by-zero error.
      It might even be worse: the division by zero error is obviously about
      division by zero, but the cast error is a bit further removed from the
      problem.  

      The improvement comes earlier, when you try to write this: 
\begin{xten}
    val c = recip(m); 
\end{xten}
      This is wrong, because \xcd`m` could be zero.  
      X10 will give you a warning or an error here (depending on the 
      \xcd`STATIC_CHECKS` compiler flag -- see \Sref{sect:StaticChecks}).  

      At this point, you have been alerted to the problem. It's your
      responsibility as an intelligent programmer to figure out the right
      thing and do it.  Testing \xcd`m` and printing a comprehensible error
      message if it's zero, while untraditional in some circles, would not be
      out of the question.

\end{description}

\subsubsection{{\tt self} in nested types}
\label{sect:NullTestsNested}

If you have a constrained type that looks like \xcd`T{c}`, where \xcd`T` is
some type and \xcd`c` some constraint, then \xcd`self` inside \xcd`c` means
{\em ``the value of type T that we're wondering whether it might be a member
of \xcd`T{c}` or not''}.  So, in \xcd`Int{self!=0}`, \xcd`self` is the
\xcd`Int` that we're saying had better not be zero.

That's a simple rule.  But it has some implications that might be brainhurty.
If you have a complicated type, there might be two \xcd`self`s inside it that
mean different things -- and are even of different types.

For example, \xcd`Array[U]{self!=null}` means ``A non-\xcd`null` array of
\xcd`U`'s''. The array itself isn't \xcd`null`. The \xcd`U`'s inside of it
might be \xcd`null`, depending on what \xcd`U` is.
\xcd`a:Array[String]{self!=null}` makes \xcd`a` be a non-\xcd`null` array of
strings, but \xcd`a` might have a \xcd`null` inside of it.

Similarly, \xcd`String{self!=null}` is the type of strings that aren't
\xcd`null`.  

So, we can use \xcd`String{self!=null}` for \xcd`U`.  
\xcd`Array[String{self!=null}]{self!=null}` is a non-\xcd`null` array of
non-\xcd`null` strings.  The first \xcd`self` refers to the \xcd`String` that
isn't null. The second one refers to the \xcd`Array` that isn't \xcd`null`.

It's easy to write an utterly incomprehensible type expression using this.  If
you find yourself tempted to do so, look at the \xcd`type` declaration
(\Sref{sect:TypeDecl}).  A couple of definitions and you can write
this: 
%%START X10: ConstraintExamples.x10 constraintexNotNull
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
var a : ArrayNotNull[StringNotNull]; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexNotNull
which is much easier to read.


\subsection{{\tt val} variables instead of {\tt self}}

Another way of making constrained types in \xcd`val` declarations easier to
read is to use the name of the variable being declared instead of \xcd`self`.  
So, you can write 
%%START X10: ConstraintExamples.x10 constraintexVal
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val n : Int{n != 0} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexVal
instead of
%%START X10: ConstraintExamples.x10 constraintexNoval
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val n : Int{self != 0} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexNoval
This isn't quite a circular definition.  It's saying that \xcd`n` is an
\xcd`Int` and \xcd`n!=0`.  

There are a few restrictions on this.  
\begin{itemize}

\item It only works on \xcd`val`s.  \xcd`var`s can never appear in
      constraints, as we see in \Sref{sect:LegalConstraints}.

\item It only works for the variable being declared.  For example, 
you can declare that the whole array of strings is non-\xcd`null`: 
\begin{xten}
val a : Array[String]{a!=null};
\end{xten}
which you might prefer to using \xcd`self` to say the same thing.
\begin{xten}
val a : Array[String]{self!=null};
\end{xten}

But the entries in the array don't have names, so, to make them be
non-\xcd`null`,  you have to write
\begin{xten}
val b : Array[String{self!=null}];
\end{xten}

If you want both the array and each entry to be non-\xcd`null` (which you
often do), you can write: 
\begin{xten}
val c : Array[String{self!=null}]{a!=null};
\end{xten}
which at least uses \xcd`self` for only one thing, unlike the equivalent 
\begin{xten}
val c : Array[String{self!=null}]{self!=null};
\end{xten}

\end{itemize}

\subsection{Guards}
\label{sect:Guards}

Guards are constraint-like expressions that control what can be done with a
class or method.  We've seen them in \Sref{subsub:type:anything}.  

A guard on a class can be specific about the generic parameters.   For
example, if we've got an interface \xcd`Flavored`: 
%%START X10: ConstraintExamples.x10 constraintGuardFlavored
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
interface Flavored {
  def flavor():Int;
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintGuardFlavored
We can demand that a generic type variable implement \xcd`Flavored`: 
%%START X10: ConstraintExamples.x10 constraintexGuardOnClass
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
class Tasting[X] {X <: Flavored} {
   def taste(x:X) = x.flavor();
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexGuardOnClass
The clause \xcd`{X <: Flavored}` is a guard.

A method can have a guard too. For example, consider a method to find the
biggest element in an array of \xcd`Int`s.  What's it supposed to do if the
array is empty and has no biggest element?  One way to deal with the problem
is to forbid it entirely, and to require that the array not be empty.  It
could be done with a guard, like this: 
%%START X10: ConstraintExamples.x10 constraintexMethodGuard
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
def max(a:Array[Int]){a.size != 0} { 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexMethodGuard
The guard \xcd`{a.size != 0}` insists that the array not be empty.
It could just as well be phrased as a constrained type: 
%%START X10: ConstraintExamples.x10 constraintexMethodGuard2
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
def min(a:Array[Int]{a.size!=0}) { 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexMethodGuard2
Use whichever way you like more.


\subsection{Legal Constraints}
\label{sect:LegalConstraints}

It would be very nice if you could write any sort of Boolean expression in
your constraints.  In fact, it would be way, way {\em too} nice.  You could
write constraints which no computer program could understand. 

\begin{finepoint}
Basic theory of computability says that there is no computer program that (1)
always halts, and (2) can accept any nullary Boolean function \xcd`f` as
input, and tell whether \xcd`f()==true`.  (Remember that \xcd`f()` might run
forever, but the tester would have to halt in finite time, so it can't just
run \xcd`f()` and see what happens.  It has to look at the code of \xcd`f`,
and any computability theory textbook will explain why that cannot work.)

So, if we allowed expressions liike \xcd`f()` in constraints, X10 would have
some trouble.  Does this compile?
\begin{xten}
val a : Int{f()} = 1;
\end{xten}
Well, if \xcd`f()==true`, it does compile, and otherwise it doesn't.  So the
X10 compiler would have to solve that unsolvable problem in order to do basic
type checking. 
\end{finepoint}

So, to keep type-checking deciable --- and fast --- only a scant handful of
things are allowed in constraints.  

\subsection{Constraints can be...}

\begin{description}
\item [Equalities:] As we've seen, we can have equalities in constraints, like
      \xcd`Int{self==3}`.
\item [Non-Equalities:] As we've seen, we can say that two things have to be
      different, like \xcd`String{self!=null}`.  (We can't use other kinds of
      inequalities, like \xcd`Int{self > 0}`.)
\item [Type Equalities and Non-Equalities:] We can require that two types
      either be the asme (\xcd`T==U`) or be different (\xcd`T!=U`), too.
      These aren't used very often.
\item [Subtyping:] We can require that one type \xcd`T` be a subtype of
      another type \xcd`U`.  This {\em is} useful, especially 
      for the guard of a class. We've seen it used already, back in
      \Sref{subsub:type:anything} and \Sref{sect:Guards}. 
\item [Property Method Invocations:] ``Property methods''
      (\Sref{sect:PropertyMethods}) are very limited sorts of methods -- they
      can say just the sorts of things that belong in constraints.
\item [Conjuctions:]  You can put several constraints together, but only with
      \xcd`&&`.  See \Sref{sect:conjunction} for details.
\item [Zero Test:] You can test to see if a type has a default value, with 
      \xcd`T haszero`.  See \Sref{sect:DefaultValue} for some examples.
\item [{\tt true} and {\tt false}:] A true constraint is always true; a false
      constraint never is.  
\end{description}

\subsubsection{Expressions Allowed In Constraints} 

When you compare expressions for equality, or invoke property methods, you re
restricted to only a few sorts of expressions.  You can write \xcd`n==0`, but
not \xcd`n == m+1`.

\begin{description}
\item [Constants:] \xcd`3` and \xcd`"fish"` and \xcd`null` and so on.
\item [{\tt val}s:] You can use \xcd`val` variables.   Not \xcd`var`s, which
      change too much for X10's constraints to understand.
\item [{\tt this}:] If the constraint is at a point in the program where
      \xcd`this` makes sense, like in a method, you can use \xcd`this` in a
      constraint.
\item [{\tt here}:] The same goes for \xcd`here`.
\item [{\tt self}:] If you are constraining a {\em type}, you can use
      \xcd`self`.  If you are writing a guard, there's no \xcd`self` to be
      found. 
\item [Properties of {\tt self}:] If \xcd`p` is a property field of
      \xcd`self`, then you can write \xcd`self.p` in a constraint.  
      Just \xcd`p` alone can mean \xcd`self.p`, if that is the only choice.
\item [{\tt val} fields of anything else:] You can extract \xcd`val` fields of anything
      else. 
\item [Property Method Invocations:] You can use a property method in a
      constraint expression, if the property method's actual expansion works
      there too.
\end{description}

\subsubsection{Having your cake and eating it too}
\label{sect:conjunction}

If you want \xcd`n` to be neither zero nor one, you can write it in one of three
ways. 
\begin{itemize}
\item \xcd`val n : Int{ n!=0,  n!=1 }`, using a comma to separate multiple
      constraints.  Commas don't mean ``and'' anywhere but constraints.  

\item \xcd`val n : Int{ n!=0 && n!=1 }`, using the regular \xcd`&&` operator
      to mean ``and''.

\item \xcd`val n : Int{ n!= 0} {n!=1}`, putting one constraint on top of
      another.  
\end{itemize}
We usually use commas, but it doesn't matter.

(You can't say ``or'' or ``not'' in constraints at all. \xcd`x||y` and \xcd`!x`
are perfectly good anywhere else, but they're not allowed in constraints.)

\subsubsection{Unrelated Constraints}

There's no requirement that the constraint involves \xcd`self`, or that a
constraint on a variable  \xcd`v` has anything to do with \xcd`v`.  
%%START X10: ConstraintExamples.x10 constraintexEnv
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val a = 1;
val b = 2;
val v : Int{a!=b} = 3;
//ERROR: val d : Int{a==b} = 4; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexEnv

The constraint on line \xlref{constraintexEnv-cright}{3} says that \xcd`v` is
an integer such that the \xcd`val`s \xcd`a` and \xcd`b` are different.  Well,
looking at the code, \xcd`a` and \xcd`b` are indeed different.  So the
constraint \xcd`a!=b` is always true, no matter what \xcd`Int` value \xcd`v`
has.  In other words, \xcd`v` can be any \xcd`Int` value.

On the other claw, if the constraint {\em isn't} true, then {\em no} value
works.  You can't even use the type \xcd`Int{a==b}` on line
\xlref{constraintexEnv-dwrong}{4} --- or the type \xcd`Int{false}` anywhere.
No matter what value you assign to \xcd`d`, it won't make \xcd`a==b`, and
won't make \xcd`false` be true.  

These unrelated constraints are a way of enforcing that certain facts are true
at {\em compile time}.  \xcd`assert` statements, like
\begin{xten}
assert a != b;
\end{xten}
can check that \xcd`a` and \xcd`b` are different at {\em runtime}.  But if you
need to know that they're different at {\em compile time}, you'll need to put
the fact into a constraint.  

(Why might you need to know that?  Some other constraint might use it.  
If you have a method \xcd`recipDiff(x,y) = 1.0/(x-y)`, 
and you're calling \xcd`recipDiff(a,b)`, 
you might need to persuade X10 that \xcd`a!=b`.)

\subsection{Using Properties}

The {\em properties} of a class or struct are the values that X10 keeps the
closest track of at compile time.  They can be used in constraints on a class.
Let's do a concrete example: points and triangles in plane geometry.
We'll call the points \xcd`Pt` to keep them from getting confused with
\xcd`x10.array.Point`.  Here it is:
%%START X10: Geometry.x10 geompoint
\fromfile{Geometry.x10}
\begin{xtennum}[]
struct Pt(x:Double, y:Double) { 
  public operator this - (that:Pt) = Pt(this.x-that.x, this.y-that.y); 
  public def len() = Math.sqrt(x*x-y*y); 
}
\end{xtennum}
%%END X10: Geometry.x10 geompoint

\begin{description}
\item [line \xlref{geompoint-props}{1}:] \xcd`x` and \xcd`y` are properties of
      \xcd`Pt`.  \bard{Do we discuss this elsewhere?}
      Making them properties like this, and not giving any other constructor,
      means that X10 will automatically give us the obvious constructor
      \xcd`Pt(xx,yy)`. 
\item [line \xlref{geompoint-op}{2}:] This line defines a binary operator of
      subtraction on \xcd`Pt`s.  We're treating them as two-dimensional
      vectors.   This isn't essential, but it does make using them very slick. 

\item [line \xlref{geompoint-len}{3}:] This is a perfectly ordinary method,
      giving the length of a vector.
\end{description}

The code for triangles will use a constraint to ensure that all triangles are
non-degenerate --- that they all have three distinct points. 
%%START X10: Geometry.x10 geomtriangle
\fromfile{Geometry.x10}
\begin{xtennum}[]
struct Triangle(p:Pt, q:Pt, r:Pt) {p != q, p != r, q != r} {
  public def area() {
     val a = (p-q).len();
     val b = (q-r).len();
     val c = (r-p).len();
     val s = (a + b + c)/2;
     val area = Math.sqrt(s * (s-a) * (s-b) * (s-c) );
     return area;
  }
}
\end{xtennum}
%%END X10: Geometry.x10 geomtriangle

Triangles have three \xcd`Pt`s, which we're phrasing as properties. The
\xcd`Triangle` class has a guard on line \xlref{geomtriangle-struct}{1}, saying
that \xcd`p`, \xcd`q`, and \xcd`r` are all different. (Obviously this approach
is going to get pretty troublesome by the time we get to heptagons, where we'd
have to write 7 variables and 28 non-equalities, and won't work at all if
we're trying to use arbitrary {$n$}-gons.  But it's a very slick approach when
it does work.)



\begin{finepoint}
We rather sneakily made \xcd`Pt` a struct rather than a class.   This matters
because \xcd`==` means different things for structs and objects.  For structs,
\xcd`p==q` is true if \xcd`p.x==q.x` and \xcd`p.y==q.y`.  For classes,
\xcd`p==q` is true if \xcd`p` and \xcd`q` are the same object.  
If \xcd`Pt` had been an object, we could have a \xcd`Triangle` with three
corners each made by a call to \xcd`new Pt(0,0)` -- three \xcd`Pt`s in the
same place, but different objects.
\end{finepoint}


\subsection{Nulls and Constraints}

Sometimes you want to forbid \xcd`null` values in your object types.  You can
do this with the constraint \xcd`{self != null}`.

If you don't have that constraint on an object type, though, \xcd`null` is
allowed. And that goes even if you do have other constraints -- {\em any}
other constraints. The point of this is that it's useful to have \xcd`null` as
a default value for object types, so you get to have it unless you
specifically say you don't. 

So, the following program is fine: 
%%START X10: ConstraintsAndNulls.x10 constraintsandnulls
\fromfile{ConstraintsAndNulls.x10}
\begin{xtennum}[]
 class Trunk(length:int){}
 class Elephant(trunk:Trunk){}
 def example() {
  val dumbo: Elephant{self.trunk.length == 3} = null;
  assert dumbo == null;
  val jumbo: Elephant{self.trunk.length ==11} = null;
}
\end{xtennum}
%%END X10: ConstraintsAndNulls.x10 constraintsandnulls

This makes for some surprises about constraints. At least, they're surprising
if you are under the mistaken impression that \xcd`==`'s in constraints mean
the same thing they mean everywhere else --- they don't! The difference is
that, in a constraint, \xcd`a.f==b` and \xcd`a.f!=b` both mean \xcd`true` if
\xcd`a==null`. Outside of a constraint, it means ``null pointer exception'',
neither true nor false.

One way you could get confused, if you don't keep this special meaning in
mind, is that \xcd`dumbo : Elephant{self.trunk.length == 3}` does {\bf not}
mean that \xcd`dumbo.trunk.length` is three!  It means, ``{\bf If}
\xcd`dumbo!=null` and \xcd`dumbo.trunk!=null`, {\bf then}
\xcd`dumbo.trunk.length` is three.''  Or, to phrase it another way, ``If
\xcd`dumbo.trunk.length` means anything at all, what it means is three.''

Another way to get confused is to notice that that \xcd`dumbo` and \xcd`jumbo`
have types that look like they couldn't possibly have any values in common.
One is for short-trunked elephants, the other for long-trunked ones, and
there's no way that the same elephant's trunk could be both three and eleven
feet long.  

Well, of course there's no such elephant.  \xcd`null` isn't an \xcd`Elephant`.
It's a non-value that can be used in place of an \xcd`Elephant`.  And
\xcd`null.trunk.length` isn't three, or eleven, or any other number -- it's an
error.

All you need to remember about this is three things: 
\begin{itemize}
\item \xcd`null` is allowed in constrained object types, unless you
      specifically say it's not.
\item Constraints on fields get fudged so that they're true for \xcd`null`,
      and don't throw null pointer exceptions.
\item You need to check for \xcd`null`s when you use constrained object types --
      the same way you need to when you use ordinary object types.  (Unless
      you constrained them to never be \xcd`null`.)
\end{itemize}

\subsection{Constraints and Subtyping}

Constrained types are types. So, sometimes, they are subtypes and supertypes
of other types. 

As always, \xcd`T <: U` if every element of \xcd`T` is also an element of
\xcd`U`.    That's all you need to remember to figure out subtypes for
constrained types.

Is \xcd`Int{self==3} <: Int`?  Well, if {$n$} is an \xcd`Int{self==3}`, then
{$n$} is an \xcd`Int` which is equal to three. (\xcd`null` isn't an \xcd`Int`,
so we don't need to worry about that special case.)  An \xcd`Int` which is
equal to three is an \xcd`Int`: being three doesn't stop it from being one. 
So, yes, \xcd`Int{self==3} <: Int`.

How about \xcd`Int{self!=3} <: Int`?  The elements of 
\xcd`Int{self!=3}` are all the \xcd`Int`s except for three -- which means
they're all \xcd`Int`s.  So, yes, \xcd`Int{self!=3} <: Int`.

In fact, \xcd`Int{c} <: Int`  for {\em any} constraint \xcd`c`.
The elements of \xcd`Int{c}` are \xcd`Int`s which satisfy \xcd`c`, so they're
\xcd`Int`s, so they're elements of \xcd`Int`.  

Some other examples: 

\begin{itemize}

\item \xcd`Int{self!=1, self!=2} <: Int{self!=1}`. 

\item \xcd`Int{self==3} <: Int{self!=4}`.  Three is one of the numbers which
      isn't four.

\item \xcd`Int{self==3}` is {\em not} a subtype of \xcd`Long{self!=3}` -- nor
      of \xcd`Long` for that matter.  \xcd`Int`s and \xcd`Long`s are different
      kinds of numbers.  Sure, \xcd`Int`s represent the same numbers as some 
      \xcd`Long`s --- but they're not the same X10 values!  

\item Adding more constraints makes a subtype.  \xcd`T{c,d} <: T{c}`.  In
      fact, if \xcd`T <: U`, then \xcd`T{c} <: U` too. 

\end{itemize}

\subsection{STATIC\_CHECKS}

X10 can seem a bit fussy about type checking at times.  For example, when you
subscript an \xcd`Array[Int]`, X10 will complain if it doesn't know that the
number of subscripts is right.  That's a perfectly sensible thing for a
compiler to complain about --- you'd be pretty unhappy if your program quietly
did something insane because an array was subscripted wrong.  Still, X10's
complaints can get annoying, especially if you know you're
right.\footnote{How often are you actually right when you know you're right?
How often do you {\em stay} right when someone else who doesn't understand
comes in two years later and changes the program around?}

So, code like this is vulnerable: 
%%START X10: ArrayInc1.x10 arrayinc
\fromfile{ArrayInc1.x10}
\begin{xtennum}[]
def fiddle(a:Array[Int]) {
  a(2) += 1;
}
\end{xtennum}
%%END X10: ArrayInc1.x10 arrayinc
The array \xcd`a` might have one subscript (and the code will work right -- if
\xcd`2` is a legitimate subscript for it, anyhow), or it might have several
(and the code will be wrong).  

You've got a choice of what to do. The \xcd`-STATIC_CHECKS` compiler flag
controls them -- so you get to decide how you want each file compiled.

What X10 and good software engineering practice want you to do is to explain
that \xcd`a` has to be a one-dimensional array, like this:
%%START X10: ArrayInc1.x10 arrayincA
\fromfile{ArrayInc1.x10}
\begin{xtennum}[]
def fiddle_A(a:Array[Int]{a.rank==1}) {
  a(2) += 1;
}
\end{xtennum}
%%END X10: ArrayInc1.x10 arrayincA
This is a bit wordy, so you can abbreviate it like this.  See
\Sref{sect:Typedef} for how to arrange this kind of abbreviation in general. 
%%START X10: ArrayInc1.x10 arrayincB
\fromfile{ArrayInc1.x10}
\begin{xtennum}[]
def fiddle_B(a:Array[Int](1)) {
  a(2) += 1;
}
\end{xtennum}
%%END X10: ArrayInc1.x10 arrayincB
If you want to be sure you're following good practices, use the
\xcd`-STATIC_CHECKS` compiler flag.  It will mark the original \xcd`fiddle`
method as a compiler error.

The error message looks like this:
\begin{verbatim}
fancy-types/ArrayInc1.x10:4: Cannot assign expression to array element of given type.    
     	 Expression: 1    
     	 Type: x10.lang.Int{self==1}    
     	 Array element: a(2)    
     	 Type: x10.lang.Int    
     	 Cause: Call invalid; calling environment does not entail the method guard.    
     	 arg types:[x10.lang.Int{self==2}]    
     	 query residue: {a.rank==1}

\end{verbatim}
The \xcd`Cause:` line is your best clue.  It says that the ambient information
(the ``calling environment'') isn't enough to tell (``entail'') that the guard
on the method call \xcd`a(2)` is true.  
(Array subscripting {\em is} a method call; see
\Sref{sect:OperatorOverloading} for why.)  

The \xcd`arg types:` line says what X10 knows about the arguments.  The
argument \xcd`2` is a thing of type \xcd`Int{self==2}`.  Hopefully this does
not come as a surprise.  This information isn't directly helpful, but it will
keep you oriented.

The \xcd`query residue` line explains what X10 needs to know that it doesn't
know.  In this case, it needs \xcd`a.rank==1`.  

So, somewhere around there, you need to add the constraint that
\xcd`a.rank==1`.\footnote{Or at least, you need to add a constraint strong
enough to prove it.  You could add {\em more} information.}
This will lead you to write \xcd`fiddle_A` or \xcd`fiddle_B`.



\subsubsection{Dynamic Checks}


But if you don't want to do that, for some reason, you can still write the
original \xcd`fiddle`.  

By default, \xcd`-STATIC_CHECKS=false`.  X10 will create {\em dynamic checks}
whenever it realizes that some constraints are missing but
satisfiable.\footnote{``satisfiable'' means that it's {\em possible} that the
constraints are right.  If X10 knows that constraints are unsatisfiable --
that they couldn't possibly be right -- X10 will mercilessly refuse to compile
your program.  But if the constraints {\em might} be right, you have more
leeway.} 
It will cast things to the types they need to be.  
In this case, \xcd`a` needs to be rank-1.  So the code behaves like this:
%%START X10: ArrayInc1.x10 arrayincdyn
\fromfile{ArrayInc1.x10}
\begin{xtennum}[]
def fiddle_dynamic(a:Array[Int]) {
  val aa : Array[Int]{self.rank==1} 
         = a as Array[Int]{self.rank==1};
  aa(2) += 1;
}
\end{xtennum}
%%END X10: ArrayInc1.x10 arrayincdyn

There are two upsides:
\begin{enumerate}
\item This compiles, and, if \xcd`fiddle` is always called
with a one-dimensional array, it always runs right.  
\item It's quicker to write if you don't bother with the details of the types.
      This can be important if you're tossing together a program in a hurry,
      especially one that will only be used once or twice. 
\end{enumerate}

There are two downsides: 
\begin{enumerate}
\item You're paying the performance cost for the dynamic checks.  Every time
      \xcd`fiddle` is called, X10 has to make sure at runtime that
      \xcd`a` is the right size.  It wouldn't have to do this if the check
      were done at compile time.
\item If, say, some other programmer doesn't read the requirements on
      \xcd`fiddle` carefully, and stupidly passes a
      fourteen-dimensional array to it, it will fail at runtime with an error
      message, like this: 
\begin{verbatim}
x10.lang.FailedDynamicCheckException: x10.array.Array[x10.lang.Int]{self.rank==1}
	at ArrayInc1.$closure_apply820_0_$_x10$lang$Int_$(ArrayInc1.java:239)
	at ArrayInc1.fiddle_dynamic_0_$_x10$lang$Int_$(ArrayInc1.java:37)
	at ArrayInc1.main(ArrayInc1.java:94)
	at ArrayInc1$$Main.runtimeCallback(ArrayInc1.java:82)
	at x10.runtime.impl.java.Runtime$$Closure$Main.$apply(Runtime.java:118)
	at x10.lang.Runtime$$Closure$141.$apply(Runtime.java:3676)
	at x10.lang.Activity.run(Activity.java:410)
	at x10.lang.Runtime$Worker.loop$O(Runtime.java:1767)
	at x10.lang.Runtime$Worker.$apply(Runtime.java:1714)
	at x10.lang.Runtime$Pool.$apply(Runtime.java:2068)
	at x10.lang.Runtime.start(Runtime.java:2519)
	at x10.runtime.impl.java.Runtime.$apply(Runtime.java:162)
	at x10.runtime.impl.java.Thread.run(Thread.java:64)
\end{verbatim}
Sometimes, this sort of error message is a bit hard to figure out.  
If you look around in your program, you won't find the dynamic check that
X10 claims is failing.  There's a good reason -- X10 generated the dynamic
check itself, so it's not actually visible in your code.  
\end{enumerate}

These disadvantages are serious enough so that X10 won't just silently insert
those dynamic checks.  It will {\em noisily} insert them.  It prints
compile-time warnings, like this:
\begin{verbatim}
x10c: 3 dynamically checked calls or field accesses, 
  run with -VERBOSE_CHECKS for more details.
\end{verbatim}
And, if you do so, you see messages like: 
\begin{verbatim}
% fancy-types/ArrayInc1.x10:4: Generated a dynamic check for the method call.
\end{verbatim}
So you can be as aware of just what X10 is doing on your behalf as you want to
be.  



\subsection{Incompleteness}

X10 knows a lot when it works with constraints, but there are a few things it
doesn't know.  If you run into one of these, you'll get a situation where (in
a perfect world) your program ought to type-check correctly, but (in X10's
approximation of perfect)  it doesn't.  These limitations won't make your
program run wrong -- they won't let it run at all.

The constraints are pretty obscure.  You probably won't run into them, and, if
you do, there's generally something simple to do about it.

The first limitation is that X10 doesn't understand very much about any
particular type.  For example, there are only two \xcd`Boolean` values,
\xcd`true` and \xcd`false`.  X10 doesn't know that.  So, if you write a
constraint like \xcd`{a!=b, b!=c, a!=c}`, where \xcd`a`, \xcd`b`, and \xcd`c`
are \xcd`Boolean`s, {\em you} know that the constraint is false.  There aren't
three different \xcd`Booleans`, so two of \xcd`a`, \xcd`b`, and \xcd`c` have
to be the same.  X10's constraint solver, unaware of this point about
\xcd`Boolean`s, can't tell that this constraint is false. 
If, somehow, you arrange for this to be a problem for you, use \xcd`false`
instead of 
\xcd`{a!=b, b!=c, a!=c}`.

The second limitation is that X10's constraint solver doesn't know that
\xcd`{x.a==1, x.a==2}` (or \xcd`{x.a==1, x.a!=1}`) implies \xcd`x==null`.
If you ever have written something like one of the first two forms, write
\xcd`x==null` instead.  It's much easier to understand, for you and for X10.


\subsection{Why Generics Lose Constraints At Runtime}

\bard{do this}


\section{Type Declarations}
\label{sect:TypeDecl}

X10 types can carry a great deal of information around with them, like the
non-null array of non-null strings we saw in \Sref{sect:NullTestsNested}.
This means that X10 types can get ridiculously long -- a type carrying a lot
of information has to write a lot of information down.  

Long type expressions are hard to write, and hard to read.  This isn't just a
matter of convenience -- though your convenience {\em does} matter.  It's hard
to get a program right if the types it uses take several lines to write down.
Here's a scrap of a program which manipulates one-dimensional non-null arrays
of two-dimensional non-null arrays of non-null strings.  We don't even know
who to format that type readably: 
%%START X10: TypeDefless.x10 typedefless
\fromfile{TypeDefless.x10}
\begin{xtennum}[]
static def first(a : Array[Array[
       String{self!=null}]{rank==2,self!=null}]
       {self!=null,rank==1})
 : String{self!=null} = a(0)(0,0); 
\end{xtennum}
%%END X10: TypeDefless.x10 typedefless

So, X10 allows you to abbreviate types, with the \xcd`type` statement.
A local \xcd`val` declaration lets you write down a long {\em computation} and
give its value a name.  A \xcd`type` declaration does the same thing, only
with a type rather than a value.  Here's one way to write the same code 
with one typedef: 
%%START X10: TypeDef1.x10 typedef1
\fromfile{TypeDef1.x10}
\begin{xtennum}[]
public static type Firstable = Array[Array[
   String{self!=null}]{rank==2,self!=null}]
   {self!=null,rank==1};
static def first(a : Firstable) = a(0)(0,0);
\end{xtennum}
%%END X10: TypeDef1.x10 typedef1

That helps a little.  The method call is down to something short, which is
good.  If there were a dozen other methods in the program working with
\xcd`Firstable`s, they all would be down to something short.  And if you were
trying to read this program, you could tell at a glance that all the
\xcd`Firstable`s were the same type, which wouldn't have been at all clear if
the types were written out in full.

But we can make matters clearer. \xcd`type` definitions can have generic
arguments and value parameters, much the same way that methods can.  So we can
do this:
%%START X10: TypeDeffed.x10 typedeffedDefs
\fromfile{TypeDeffed.x10}
\begin{xtennum}[]
static def first(a : Firstable) = a(0)(0,0);

static type Nonnull[T]{T <: Object} = T{self!=null};
static type StringNN = Nonnull[String];
static type ArrayNN[T](n:Int) = Array[T]{self!=null, rank==n};
static type ArrayNN1[T] = ArrayNN[T](1);
static type ArrayNN2[T] = ArrayNN[T](2);
static type Firstable = ArrayNN1[ArrayNN2[StringNN]];
\end{xtennum}
%%END X10: TypeDeffed.x10 typedeffedDefs

\begin{description}

\item [line \xlref{typedeffedDefs-nonnull}{}:]  \xcd`Nonnull[T]` is a variant
      of \xcd`T`, restricted to be not \xcd`null`.  The \xcd`[T]` part is a
      generic parameter, just like on a class or method. The 
      \xcd`{T <: Object}` is a guard, just like on a method.  Only objects can
      possibly 
      be \xcd`null`, so we should only be applying \xcd`Nonnull` to object ---
      that is, to types \xcd`T` which are subtypes of \xcd`Object`.  

\item [line \xlref{typedeffedDefs-stringnn}{}:] This defines \xcd`StringNN` as
      a non-null string.  This is probably a useful type for this program,
      which seems to want to work a lot with non-null strings.  We used it on
      line \xlref{typedeffedDefs-first}{}, as the return type of \xcd`first`,
      as well as in the definition of \xcd`Firstable` on line
      \xlref{typedeffedDefs-firstable}{}. 

\item [line \xlref{typedeffedDefs-arraynn}{}:] \xcd`ArrayNN[T](n)` is an
      \xcd`n`-dimensional, non-\xcd`null` array of \xcd`T`'s.  The \xcd`[T]`
      is a generic parameter, as usual. The \xcd`(n:Int)` is an {\em integer}
      parameter. On the right-hand side, we use \xcd`n` in the constraint on
      the rank of the array.

\item [line \xlref{typedeffedDefs-array1}{}:] Using \xcd`ArrayNN[T](n)`, we'll
      define the kinds of array we actually use.  We could have skipped this
      step, writing \xcd`ArrayNN[ArrayNN[StringNN](2)](1)` for line 
      \xlref{typedeffedDefs-firstable}{}.  Providing the extra abstraction
      seemed a bit nicer, albeit wordier. It doesn't take too many nested
      brackets and parentheses to make it hard to tell which \xcd`(2)` goes
      with which \xcd`ArrayNN`.  

\item [line \xlref{typedeffedDefs-firstable}{}:] The definition of
      \xcd`Firstable`, using the constructs we've introduced, is about as
      clear as it could be.   
\end{description}

While \xcd`Nonnull` isn't part of the stardard X10 library, there is a
standard \xcd`type` for \xcd`Array`: 
\begin{xten}
public type Array[T](r:Int) = Array[T]{self.rank==r};
\end{xten}
So, \xcd`Array[Int](3)` is a three-dimensional array of \xcd`Int`s, and so on.  
Some related types do the same thing: 
\begin{xten}
public type Point(r: Int) = Point{self.rank==r};
\end{xten}
\bard{Give example of use}


{\bf True Confession:} If you're working with a complicated structure like the
\xcd`Firstable` in this section, you might be better off encapsulating it as a
class or a struct, and defining a clear interface for it, rather than keeping
it as one devastating type expression.  Even breaking the type into a series
of clean abstractions with \xcd`type` definitions is often an inferior choice.
Elaborate types are likely to need to be changed as the program evolves, and
all the code using them is going to have to change as well.  A class or struct
can encapsulate the changeable bits inside a stable and readable inteface.


\section{Type Inference}
\bard{do this!}

\section{Generics}
\bard{do this!}

\section{Default Values}
\label{sect:DefaultValues}

Some X10 types have {\em default values}.  The default value for an \xcd`Int`
is zero; the default value for an unconstrained object type is \xcd`null`.  


The default value of a constrained type is the default value of the
unconstrained type if that satisfies the constraint; the constrained type
doesn't have a default otherwise. 
For example, the default value of \xcd`Int{self != 3}` is zero, just like
\xcd`Int`.  \xcd`Int{self != 0}` doesn't have a default value, since the
default value of \xcd`Int`, zero, is constrained away. 

\xcd`Int{self==4}` also doesn't have a default value.  The default value for
any constrained \xcd`Int` type is zero if that works, and \xcd`0!=4`, so it
doesn't have one.  You might want its default value to be \xcd`4`, since
that's the only value that an \xcd`Int{self==4}` could have. But no, the
only choice for a default value of any sort of \xcd`Int` is zero.


Default values show up once in a while.  Not as often as you might think --
local variables need to be initialized before you can use them, so X10 never
uses their default values.  \xcd`val` fields of objects and struct also need
to get initialized before they are used.  But \xcd`var` fields of objects
don't necessarily need to get initialized before they are used, and, if they
aren't initialized, they get the default value of their type.


%%START X10: Default.x10 defaultex
\fromfile{Default.x10}
\begin{xtennum}[]
 class Fault {
  public var d : Int;
  static def example() {
    val f = new Fault();
    assert f.d == 0; 
  }
}
\end{xtennum}
%%END X10: Default.x10 defaultex


\bard{hasdefault}


\section{Common Ancestors of Types}
\bard{do this!}
\section{When Types Don't Work}
\bard{do this!}

