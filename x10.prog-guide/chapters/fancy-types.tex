\chapter{Fancy Types}

X10's types are a lot more powerful than we've seen so far.  They can do a lot
for you that types in Java and C++ can't do, if you want.   

Now, most of what types do for you is to prevent mistakes.  Here's a mistake: 
\begin{xten}
var total : Int = 0; 
total += "3";
\end{xten}
\xcd`total` is an integer.  You can't add a \xcd`String` value into it. 
This is a bit tricky, because you can add a \xcd`String` {\em to} it: 
\xcd`0 + "3"` evaluates to the string \xcd`"03"`.  In some languages, you {\em
can} add a string into an integer if the string contains a number, so adding
\xcd`"3"` into \xcd`total` would behave just like adding \xcd`3` into
\xcd`total`.  

A good type system will catch this mistake as early as possible, and tell you
about it in as useful a way as possible.  For X10, this means that it'll catch
the mistake when you try to compile your program -- or even sooner, if you're
using the programming environment X10DT -- and it'll print out a message
telling you that the code doesn't fit together right.   

The other thing that well-designed types do is try not to bother you too much.
This is a bit tricky. The ultimate purpose of types {\em is} to bother you --
to get in your face when you're about to goof up. At the very least, you have
to do some work in order to get any value of them. You have to write down some
types in your program, enough to tell X10 what you mean, so it can catch when
you don't do what you meant.  But X10 often lets you leave types off, so
they're not {\em too} much in your face.




\section{Constrained Types}

Here's a perfectly innocuous bit of code that looks just fine: 
%%START X10: ArrayRef.x10 arrayrefRank
\fromfile{ArrayRef.x10}
\begin{xtennum}[]
val a : Array[Int] = [1,2,3];
Console.OUT.println("a(1)=" + a(1));
\end{xtennum}
%%END X10: ArrayRef.x10 arrayrefRank
But when you go to compile it, you get a warning message: 
\begin{verbatim}
Generated a dynamic check for the method call.
\end{verbatim}
(Or, if you are using \xcd`STATIC_CHECKS`, it won't compile at all.)  

What's wrong here is that \xcd`Array[Int]` covers arrays of many different
ranks -- one-dimensional ones like \xcd`[1,2,3]`, two-dimensional,
ten-dimensional, or whatever you like.  When \xcd`a` was declared to have
type \xcd`Array[Int]`, we told X10 to forget what rank \xcd`a`
had.\footnote{This is why you should use \xcd`val a <: Array[Int]...` 
whenever you can -- \xcd`<:` in a \xcd`val` doesn't lose track of this kind of
thing.}

So, when X10 goes to use \xcd`a`, it doesn't know how many subscripts it
takes.   Giving it one subscript, in \xcd`a(1)`, might be right, or it might
be wrong. X10 doesn't know.  So, with dynamic checks on, it sticks in a test
to find out.  

And, since X10 doesn't know, it will do the same thing for \xcd`a(1,2)`.
That will fail at runtime, since \xcd`a` is one-dimensional.  

It would be nice if X10 could handle this sensibly -- if X10 could know that
\xcd`a` was one-dimensional, that one subscript was right, and two were wrong.  

Well, it can do that --- that, and a whole lot more.  The mechanism it uses is
called {\em constrained types}.  Constrained types track things that the
compiler knows about your data, like the ranks of arrays, or that particular
variables aren't \xcd`null`.  


\subsubsection{Tracking Nulls}




One common problem in programs (in most object-oriented languages) is that
some parts of code assume that some objects aren't \xcd`null`, but other parts
of code don't know about this assumption and set them to \xcd`null`.  This can
cause \xcd`NullPointerException`s and considerable premature gray hair.  
For example, 

%%START X10: NeedsNullCheck.x10 needsnullcheck
\fromfile{NeedsNullCheck.x10}
\begin{xtennum}[]
val x : Person = lookUp("Kim Geep");
Console.OUT.println("Kim's phone number is " + x.phoneNumber());
\end{xtennum}
%%END X10: NeedsNullCheck.x10 needsnullcheck

If Kim isn't in the database, \xcd`x.phoneNumber()` will throw an exception.  

If you want to protect yourself against this in X10, you can.  Declare \xcd`x`
with a type that says ``\xcd`x` is a \xcd`Person`, but not \xcd`null`''.  
Using this type obligates you to convince X10 that whatever value you give
\xcd`x` is not null.  Three good ways to convince X10 are: (1) use a
constructor call, since constructors never return \xcd`null`. 
(2) use a method declared to return a non-null value, though you will have to
convince X10 that method is defined properly. (3) Check the value at runtime,
with a type-cast (``\xcd`as`'') operation, 
and make sure it's not \xcd`null` there.\footnote{Method 3, checking values at
runtime, is pretty familiar from defensive programming in Java or C++.  X10's
types, if used this way, have the advantage that you can't {\em forget} to do
the check -- if you forget, your program won't compile.}

For our sample program, we choose a version of database lookup that is
guaranteed never to return \xcd`null`.  If \xcd`lookUpOrCreate(name)` doesn't
find \xcd`name` in the database, it creates a new record for that name.  This
approach doesn't make sense for all applications\footnote{Not even for this
one -- how do we really know the phone number of a newly-created
\xcd`Person`?}.  (In many cases, if some crucial datum really is missing,
there's no way to figure it out, and the best thing that can be done is to
report the error and ask a human for help.  Throwing a
\xcd`NullPointerException` is a greatly inferior choice.)

The code that uses non-null \xcd`Person`s is very much like the code that used
possibly-\xcd`null` ones: 
%%START X10: HasNullCheck.x10 hasnullcheck
\fromfile{HasNullCheck.x10}
\begin{xtennum}[]
val x : Person{self!=null} = lookUpOrCreate("Kim Geep");
Console.OUT.println("Kim's phone number is " + x.phoneNumber());
\end{xtennum}
%%END X10: HasNullCheck.x10 hasnullcheck

The code of \xcd`lookUpOrCreate` keeps track of the fact that its values are
never \xcd`null`.  The database \xcd`db` is a hash-table of
non-\xcd`null`\xcd`Person`s.  \xcd`lookUpOrCreate` itself returns a non-null
\xcd`Person`.  The constructor call at line \xlref{hasnullcheckDB-ctor}{6}
always produces a non-\xcd`null` value, and X10 knows that, so it works out
fine too.
%%START X10: HasNullCheck.x10 hasnullcheckDB
\fromfile{HasNullCheck.x10}
\begin{xtennum}[]
static val db = new HashMap[String, Person{self!=null}]();
static def lookUpOrCreate(name:String) : Person{self!=null} = {
  if( db.containsKey(name)) {
     return db.getOrThrow(name) ;
  }
  val p = new Person(); 
  db.put(name, p);
  return p;
}
\end{xtennum}
%%END X10: HasNullCheck.x10 hasnullcheckDB




\subsection{{\tt self}, {\tt this}, and all that}

Now, it's time to learn what that \xcd`self!=null` means.  You already know
\xcd`!=` and \xcd`null`, but \xcd`self` is new.  

When we're using a type, we can think of it as a test, asking if some thing
under consideration is a member of the type or not.  So, for the type
\xcd`Int`, imagine asking if \xcd`true` is a member (no), or \xcd`18` is
(yes).  With types that come from classes and such, like \xcd`Int`, we don't
need to have a name for the thing under consideration.
When we write a constraint, we do need a name for it -- and that name is
a special X10 keyword, \xcd`self`.  

So, we can write some other constraints.  Like this one, which says that the
variable \xcd`three` is an \xcd`Int` which is equal to \xcd`3`.  
%%START X10: ConstraintExamples.x10 constraintex1
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val three : Int{self==3} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintex1
Of course, if you try to set it to something that {\em isn't} three, it won't
work.  This doesn't compile:
%%START X10: ConstraintExamples.x10 constraintex2
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val four : Int{self==3} = 4; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintex2

Not-equals constraints are sometimes useful for excluding a few problem
values.    For example, if you're defining a reciprocal function, you might
want to constrain the input to avoid dividing by zero:
%%START X10: ConstraintExamples.x10 constraintexrecip
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
static def recip(n:Int{self!=0}) = 1.0/n; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexrecip

This isn't a terrible idea, though it does require you to prove to X10 that
numbers are non-zero when you take their reciprocals.  Here are a few ways
that you can do it: 
%%START X10: ConstraintExamples.x10 constraintexUseRecip
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
static def useRecip(m:Int, n:Int{self!=0}) {
  val a = recip(n); 
  val three : Int{self==3} = 3; 
  val b = recip(three);
  val c = recip(m as Int{self!=0});
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexUseRecip


\begin{description}
\item [Line \xlref{constraintexUseRecip-a}{2}:] Use an argument which has been
      declared to be the right type.  That's an ordinary way to call methods
      anyhow.  Here, the right type is \xcd`Int{self!=0}`.  Since \xcd`n` has
      that type, it's fine.
\item [Line \xlref{constraintexUseRecip-b}{4}:] Use an argument which has a
      {\em more specific} type.  You're used to doing this too, when you have
      a method that takes a \xcd`Person` as an argument and you give it a
      subclass, like \xcd`Dentist`.  

      Here we're doing the same thing, in a
      slightly different way. 
      The type of \xcd`three` is \xcd`Int{self==3}`.  That's a subtype of 
      \xcd`Int{self!=0}`, because every number that {\em is} three {\em isn't}
      zero.    The official word for this is {\em subtyping by strengthening}.  
      \xcd`self==3` is logically {\em stronger} than \xcd`self!=0` --- also
      pronounced ``\xcd`self==3` implies \xcd`self!=0`''.  
      A constrained type with a stronger constraint is always a subtype of a
      type with the same base and a weaker one.  

      (As usual, we didn't have to write the type on line
      \xlref{constraintexUseRecip-decl}{3}.  We  just wrote it to make the
      example clearer.)
      
\item [Line \xlref{constraintexUseRecip-c}{5}:] 
      Use a {\em cast}.  
      At some point, you're going to
      have a value like \xcd`m`, which you don't know in advance is not zero,
      and you're going to have to tell X10 that it's not zero.  The way you
      say ``it's not zero'', here, is to use a type cast  
      \xcd`m as Int{self!=0}`.  This is just the same as any other time you
      have a value of one type and need it to be another type.

      Of course, \xcd`m` might be zero.  If \xcd`m` is zero, this cast fails
      -- \xcd`m as Int{self!=0}` first makes sure that \xcd`m` is an integer
      (which it can do at compile-time), and then that it's not zero (which
      has to be done at runtime).    If \xcd`m` is zero, this throws an
      exception, the same as any other attempt to cast a value to some type it
      isn't.   

      This isn't much of an improvement over getting a division-by-zero error.
      It might even be worse: the division by zero error is obviously about
      division by zero, but the cast error is a bit further removed from the
      problem.  

      The improvement comes earlier, when you try to write this: 
\begin{xten}
    val c = recip(m); 
\end{xten}
      This is wrong, because \xcd`m` could be zero.  
      X10 will give you a warning or an error here (depending on the 
      \xcd`STATIC_CHECKS` compiler flag -- see \Sref{sect:StaticChecks}).  

      At this point, you have been alerted to the problem. It's your
      responsibility as an intelligent programmer to figure out the right
      thing and do it.  Testing \xcd`m` and printing a comprehensible error
      message if it's zero, while untraditional in some circles, would not be
      out of the question.

\end{description}

\subsubsection{{\tt self} in nested types}

If you have a constrained type that looks like \xcd`T{c}`, where \xcd`T` is
some type and \xcd`c` some constraint, then \xcd`self` inside \xcd`c` means
{\em ``the value of type T that we're wondering whether it might be a member
of \xcd`T{c}` or not''}.  So, in \xcd`Int{self!=0}`, \xcd`self` is the
\xcd`Int` that we're saying had better not be zero.

That's a simple rule.  But it has some implications that might be brainhurty.
If you have a complicated type, there might be two \xcd`self`s inside it that
mean different things -- and are even of different types.

For example, \xcd`Array[U]{self!=null}` means ``A non-\xcd`null` array of
\xcd`U`'s''. The array itself isn't \xcd`null`. The \xcd`U`'s inside of it
might be \xcd`null`, depending on what \xcd`U` is.
\xcd`a:Array[String]{self!=null}` makes \xcd`a` be a non-\xcd`null` array of
strings, but \xcd`a` might have a \xcd`null` inside of it.

Similarly, \xcd`String{self!=null}` is the type of strings that aren't
\xcd`null`.  

So, we can use \xcd`String{self!=null}` for \xcd`U`.  
\xcd`Array[String{self!=null}]{self!=null}` is a non-\xcd`null` array of
non-\xcd`null` strings.  The first \xcd`self` refers to the \xcd`String` that
isn't null. The second one refers to the \xcd`Array` that isn't \xcd`null`.

It's easy to write an utterly incomprehensible type expression using this.  If
you find yourself tempted to do so, look at the \xcd`type` declaration
(\Sref{sect:TypeDecl}).  A couple of definitions and you can write
this: 
%%START X10: ConstraintExamples.x10 constraintexNotNull
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
var a : ArrayNotNull[StringNotNull]; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexNotNull
which is much easier to read.


\subsection{{\tt val} variables instead of {\tt self}}

Another way of making constrained types in \xcd`val` declarations easier to
read is to use the name of the variable being declared instead of \xcd`self`.  
So, you can write 
%%START X10: ConstraintExamples.x10 constraintexVal
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val n : Int{n != 0} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexVal
instead of
%%START X10: ConstraintExamples.x10 constraintexNoval
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val n : Int{self != 0} = 3;
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexNoval
This isn't quite a circular definition.  It's saying that \xcd`n` is an
\xcd`Int` and \xcd`n!=0`.  

There are a few restrictions on this.  
\begin{itemize}

\item It only works on \xcd`val`s.  \xcd`var`s can never appear in
      constraints, as we see in \Sref{sect:LegalConstraints}.

\item It only works for the variable being declared.  For example, 
you can declare that the whole array of strings is non-\xcd`null`: 
\begin{xten}
val a : Array[String]{a!=null};
\end{xten}
which you might prefer to using \xcd`self` to say the same thing.
\begin{xten}
val a : Array[String]{self!=null};
\end{xten}

But the entries in the array don't have names, so, to make them be
non-\xcd`null`,  you have to write
\begin{xten}
val b : Array[String{self!=null}];
\end{xten}

If you want both the array and each entry to be non-\xcd`null` (which you
often do), you can write: 
\begin{xten}
val c : Array[String{self!=null}]{a!=null};
\end{xten}
which at least uses \xcd`self` for only one thing, unlike the equivalent 
\begin{xten}
val c : Array[String{self!=null}]{self!=null};
\end{xten}

\end{itemize}

\subsection{Guards}
\label{sect:Guards}

Guards are constraint-like expressions that control what can be done with a
class or method.  We've seen them in \Sref{subsub:type:anything}.  

A guard on a class can be specific about the generic parameters.   For
example, if we've got an interface \xcd`Flavored`: 
%%START X10: ConstraintExamples.x10 constraintGuardFlavored
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
interface Flavored {
  def flavor():Int;
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintGuardFlavored
We can demand that a generic type variable implement \xcd`Flavored`: 
%%START X10: ConstraintExamples.x10 constraintexGuardOnClass
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
class Tasting[X] {X <: Flavored} {
   def taste(x:X) = x.flavor();
}
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexGuardOnClass
The clause \xcd`{X <: Flavored}` is a guard.

A method can have a guard too. For example, consider a method to find the
biggest element in an array of \xcd`Int`s.  What's it supposed to do if the
array is empty and has no biggest element?  One way to deal with the problem
is to forbid it entirely, and to require that the array not be empty.  It
could be done with a guard, like this: 
%%START X10: ConstraintExamples.x10 constraintexMethodGuard
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
def max(a:Array[Int]){a.size != 0} { 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexMethodGuard
The guard \xcd`{a.size != 0}` insists that the array not be empty.
It could just as well be phrased as a constrained type: 
%%START X10: ConstraintExamples.x10 constraintexMethodGuard2
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
def min(a:Array[Int]{a.size!=0}) { 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexMethodGuard2
Use whichever way you like more.


\subsection{Legal Constraints}
\label{sect:LegalConstraints}

It would be very nice if you could write any sort of Boolean expression in
your constraints.  In fact, it would be way, way {\em too} nice.  You could
write constraints which no computer program could understand. 

\begin{finepoint}
Basic theory of computability says that there is no computer program that (1)
always halts, and (2) can accept any nullary Boolean function \xcd`f` as
input, and tell whether \xcd`f()==true`.  (Remember that \xcd`f()` might run
forever, but the tester would have to halt in finite time, so it can't just
run \xcd`f()` and see what happens.  It has to look at the code of \xcd`f`,
and any computability theory textbook will explain why that cannot work.)

So, if we allowed expressions liike \xcd`f()` in constraints, X10 would have
some trouble.  Does this compile?
\begin{xten}
val a : Int{f()} = 1;
\end{xten}
Well, if \xcd`f()==true`, it does compile, and otherwise it doesn't.  So the
X10 compiler would have to solve that unsolvable problem in order to do basic
type checking. 
\end{finepoint}

So, to keep type-checking deciable --- and fast --- only a scant handful of
things are allowed in constraints.  

\subsection{Constraints can be...}

\begin{description}
\item [Equalities:] As we've seen, we can have equalities in constraints, like
      \xcd`Int{self==3}`.
\item [Non-Equalities:] As we've seen, we can say that two things have to be
      different, like \xcd`String{self!=null}`.  (We can't use other kinds of
      inequalities, like \xcd`Int{self > 0}`.)
\item [Type Equalities and Non-Equalities:] We can require that two types
      either be the asme (\xcd`T==U`) or be different (\xcd`T!=U`), too.
      These aren't used very often.
\item [Subtyping:] We can require that one type \xcd`T` be a subtype of
      another type \xcd`U`.  This {\em is} useful, especially 
      for the guard of a class. We've seen it used already, back in
      \Sref{subsub:type:anything} and \Sref{sect:Guards}. 
\item [Property Method Invocations:] ``Property methods''
      (\Sref{sect:PropertyMethods}) are very limited sorts of methods -- they
      can say just the sorts of things that belong in constraints.
\item [Conjuctions:]  You can put several constraints together, but only with
      \xcd`&&`.  See \Sref{sect:conjunction} for details.
\item [Zero Test:] You can test to see if a type has a default value, with 
      \xcd`T haszero`.  See \Sref{sect:DefaultValue} for some examples.
\item [{\tt true} and {\tt false}:] A true constraint is always true; a false
      constraint never is.  
\end{description}

\subsubsection{Expressions Allowed In Constraints} 

When you compare expressions for equality, or invoke property methods, you re
restricted to only a few sorts of expressions.  You can write \xcd`n==0`, but
not \xcd`n == m+1`.

\begin{description}
\item [Constants:] \xcd`3` and \xcd`"fish"` and \xcd`null` and so on.
\item [{\tt val}s:] You can use \xcd`val` variables.   Not \xcd`var`s, which
      change too much for X10's constraints to understand.
\item [{\tt this}:] If the constraint is at a point in the program where
      \xcd`this` makes sense, like in a method, you can use \xcd`this` in a
      constraint.
\item [{\tt here}:] The same goes for \xcd`here`.
\item [{\tt self}:] If you are constraining a {\em type}, you can use
      \xcd`self`.  If you are writing a guard, there's no \xcd`self` to be
      found. 
\item [Properties of {\tt self}:] If \xcd`p` is a property field of
      \xcd`self`, then you can write \xcd`self.p` in a constraint.  
      Just \xcd`p` alone can mean \xcd`self.p`, if that is the only choice.
\item [{\tt val} fields of anything else:] You can extract \xcd`val` fields of anything
      else. 
\item [Property Method Invocations:] You can use a property method in a
      constraint expression, if the property method's actual expansion works
      there too.
\end{description}

\subsubsection{Having your cake and eating it too}
\label{sect:conjunction}

If you want \xcd`n` to be neither zero nor one, you can write it in one of three
ways. 
\begin{itemize}
\item \xcd`val n : Int{ n!=0,  n!=1 }`, using a comma to separate multiple
      constraints.  Commas don't mean ``and'' anywhere but constraints.  

\item \xcd`val n : Int{ n!=0 && n!=1 }`, using the regular \xcd`&&` operator
      to mean ``and''.

\item \xcd`val n : Int{ n!= 0} {n!=1}`, putting one constraint on top of
      another.  
\end{itemize}
We usually use commas, but it doesn't matter.

(You can't say ``or'' or ``not'' in constraints at all. \xcd`x||y` and \xcd`!x`
are perfectly good anywhere else, but they're not allowed in constraints.)

\subsubsection{Unrelated Constraints}

There's no requirement that the constraint involves \xcd`self`, or that a
constraint on a variable  \xcd`v` has anything to do with \xcd`v`.  
%%START X10: ConstraintExamples.x10 constraintexEnv
\fromfile{ConstraintExamples.x10}
\begin{xtennum}[]
val a = 1;
val b = 2;
val v : Int{a!=b} = 3;
//ERROR: val d : Int{a==b} = 4; 
\end{xtennum}
%%END X10: ConstraintExamples.x10 constraintexEnv

The constraint on line \xlref{constraintexEnv-cright}{3} says that \xcd`v` is
an integer such that the \xcd`val`s \xcd`a` and \xcd`b` are different.  Well,
looking at the code, \xcd`a` and \xcd`b` are indeed different.  So the
constraint \xcd`a!=b` is always true, no matter what \xcd`Int` value \xcd`v`
has.  In other words, \xcd`v` can be any \xcd`Int` value.

On the other claw, if the constraint {\em isn't} true, then {\em no} value
works.  You can't even use the type \xcd`Int{a==b}` on line
\xlref{constraintexEnv-dwrong}{4} --- or the type \xcd`Int{false}` anywhere.
No matter what value you assign to \xcd`d`, it won't make \xcd`a==b`, and
won't make \xcd`false` be true.  

These unrelated constraints are a way of enforcing that certain facts are true
at {\em compile time}.  \xcd`assert` statements, like
\begin{xten}
assert a != b;
\end{xten}
can check that \xcd`a` and \xcd`b` are different at {\em runtime}.  But if you
need to know that they're different at {\em compile time}, you'll need to put
the fact into a constraint.  

(Why might you need to know that?  Some other constraint might use it.  
If you have a method \xcd`recipDiff(x,y) = 1.0/(x-y)`, 
and you're calling \xcd`recipDiff(a,b)`, 
you might need to persuade X10 that \xcd`a!=b`.)

\subsection{Using Properties}

The {\em properties} of a class or struct are the values that X10 keeps the
closest track of at compile time.  They can be used in constraints on a class.
Let's do a concrete example: points and triangles in plane geometry.
We'll call the points \xcd`Pt` to keep them from getting confused with
\xcd`x10.array.Point`.  Here it is:
%%START X10: Geometry.x10 geompoint
\fromfile{Geometry.x10}
\begin{xtennum}[]
struct Pt(x:Double, y:Double) { 
  public operator this - (that:Pt) = Pt(this.x-that.x, this.y-that.y); 
  public def len() = Math.sqrt(x*x-y*y); 
}
\end{xtennum}
%%END X10: Geometry.x10 geompoint

\begin{description}
\item [line \xlref{geompoint-props}{1}:] \xcd`x` and \xcd`y` are properties of
      \xcd`Pt`.  \bard{Do we discuss this elsewhere?}
      Making them properties like this, and not giving any other constructor,
      means that X10 will automatically give us the obvious constructor
      \xcd`Pt(xx,yy)`. 
\item [line \xlref{geompoint-op}{2}:] This line defines a binary operator of
      subtraction on \xcd`Pt`s.  We're treating them as two-dimensional
      vectors.   This isn't essential, but it does make using them very slick. 

\item [line \xlref{geompoint-len}{3}:] This is a perfectly ordinary method,
      giving the length of a vector.
\end{description}

The code for triangles will use a constraint to ensure that all triangles are
non-degenerate --- that they all have three distinct points. 
%%START X10: Geometry.x10 geomtriangle
\fromfile{Geometry.x10}
\begin{xtennum}[]
struct Triangle(p:Pt, q:Pt, r:Pt) {p != q, p != r, q != r} {
  public def area() {
     val a = (p-q).len();
     val b = (q-r).len();
     val c = (r-p).len();
     val s = (a + b + c)/2;
     val area = Math.sqrt(s * (s-a) * (s-b) * (s-c) );
     return area;
  }
}
\end{xtennum}
%%END X10: Geometry.x10 geomtriangle

Triangles have three \xcd`Pt`s, which we're phrasing as properties. The
\xcd`Triangle` class has a guard on line \xlref{geomtriangle-struct}{1}, saying
that \xcd`p`, \xcd`q`, and \xcd`r` are all different. (Obviously this approach
is going to get pretty troublesome by the time we get to heptagons, where we'd
have to write 7 variables and 28 non-equalities, and won't work at all if
we're trying to use arbitrary {$n$}-gons.  But it's a very slick approach when
it does work.)



\begin{finepoint}
We rather sneakily made \xcd`Pt` a struct rather than a class.   This matters
because \xcd`==` means different things for structs and objects.  For structs,
\xcd`p==q` is true if \xcd`p.x==q.x` and \xcd`p.y==q.y`.  For classes,
\xcd`p==q` is true if \xcd`p` and \xcd`q` are the same object.  
If \xcd`Pt` had been an object, we could have a \xcd`Triangle` with three
corners each made by a call to \xcd`new Pt(0,0)` -- three \xcd`Pt`s in the
same place, but different objects.
\end{finepoint}


\subsection{Nulls and Constraints}

Sometimes you want to forbid \xcd`null` values in your object types.  You can
do this with the constraint \xcd`{self != null}`.

If you don't have that constraint on an object type, though, \xcd`null` is
allowed. And that goes even if you do have other constraints -- {\em any}
other constraints. The point of this is that it's useful to have \xcd`null` as
a default value for object types, so you get to have it unless you
specifically say you don't. 

So, the following program is fine: 
%%START X10: ConstraintsAndNulls.x10 constraintsandnulls
\fromfile{ConstraintsAndNulls.x10}
\begin{xtennum}[]
 class Trunk(length:int){}
 class Elephant(trunk:Trunk){}
 def example() {
  val dumbo: Elephant{self.trunk.length == 3} = null;
  assert e == null;
  val jumbo: Elephant{self.trunk.length ==11} = null;
}
\end{xtennum}
%%END X10: ConstraintsAndNulls.x10 constraintsandnulls

This makes for some surprises about constraints. At least, they're surprising
if you are under the mistaken impression that \xcd`==`'s in constraints mean
the same thing they mean everywhere else --- they don't! The difference is
that, in a constraint, \xcd`a.f==b` and \xcd`a.f!=b` both mean \xcd`true` if
\xcd`a==null`. Outside of a constraint, it means ``null pointer exception'',
neither true nor false.

One way you could get confused, if you don't keep this special meaning in
mind, is that \xcd`dumbo : Elephant{self.trunk.length == 3}` does {\bf not}
mean that \xcd`dumbo.trunk.length` is three!  It means, ``{\bf If}
\xcd`dumbo!=null` and \xcd`dumbo.trunk!=null`, {\bf then}
\xcd`dumbo.trunk.length` is three.''  Or, to phrase it another way, ``If
\xcd`dumbo.trunk.length` means anything at all, what it means is three.''

Another way to get confused is to notice that that \xcd`dumbo` and \xcd`jumbo`
have types that look like they couldn't possibly have any values in common.
One is for short-trunked elephants, the other for long-trunked ones, and
there's no way that the same elephant's trunk could be both three and eleven
feet long.  

Well, of course there's no such elephant.  \xcd`null` isn't an \xcd`Elephant`.
It's a non-value that can be used in place of an \xcd`Elephant`.  And
\xcd`null.trunk.length` isn't three, or eleven, or any other number -- it's an
error.

All you need to remember about this is three things: 
\begin{itemize}
\item \xcd`null` is allowed in constrained object types, unless you
      specifically say it's not.
\item Constraints on fields get fudged so that they're true for \xcd`null`,
      and don't throw null pointer exceptions.
\item You need to check for \xcd`null`s when you use constrained object types --
      the same way you need to when you use ordinary object types.  (Unless
      you constrained them to never be \xcd`null`.)
\end{itemize}




\subsection{Constraints and Subtyping}
\subsection{STATIC\_CHECKS}
\subsection{Incompleteness}
\subsection{Why Generics Lose Constraints At Runtime}

\section{Type Declarations}
\label{sect:TypeDecl}
\bard{do this -- note non-null type decl for niceifying Array[String{self!=null}]{self!=null} }
\section{Type Inference}
\bard{do this!}
\section{Generics}
\bard{do this!}
\section{Default Values}
\bard{do this!}
\section{Common Ancestors of Types}
\bard{do this!}
\section{When Types Don't Work}
\bard{do this!}

